<!DOCTYPE html>
{% load i18n %}
<html lang="{{ LANGUAGE_CODE }}" dir="{% if LANGUAGE_BIDI %}rtl{% else %}ltr{% endif %}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Email AI Agent</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #f5f5f5;
            --text-color: #333;
            --error-color: #d9534f;
            --success-color: #5cb85c;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --card-bg: #ffffff;
            --border-color: #e0e0e0;
            --text-secondary: #666;
        }
        [data-theme="dark"] {
            --primary-color: #8ab4f8;
            --secondary-color: #121212;
            --text-color: #e6e6e6;
            --error-color: #cf6679;
            --success-color: #81c995;
            --card-bg: #1a1a1a;
            --border-color: #333;
            --text-secondary: #ccc;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--secondary-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        .container {
            width: 100%;
            max-width: 800px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        [data-theme="dark"] .container { background-color: #1e1e1e; }
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(255, 255, 255, 0.65);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        [data-theme="dark"] .overlay { background: rgba(0, 0, 0, 0.6); }
        .overlay-content {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-color);
            font-weight: 500;
        }
        .spinner {
            width: 32px;
            height: 32px;
            border: 4px solid #ddd;
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 0.9s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            text-align: center;
        }
        header h1 {
            margin: 0;
            font-size: 1.8em;
        }
        main {
            padding: 20px;
        }
        .command-form {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        #command-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }
        #command-submit {
            padding: 10px 20px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        #command-submit:hover {
            background-color: #357abd;
        }
        .results {
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 100px;
            padding: 15px;
            background-color: #fafafa;
            max-height: 70vh; /* Allow long results to be scrollable */
            overflow-y: auto;
        }
        [data-theme="dark"] .results { background-color: #121212; border-color: #333; }
        .confirmation-dialog {
            background-color: #fffbe6;
            border: 1px solid #ffe58f;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        [data-theme="dark"] .confirmation-dialog { background-color: #1b1b1b; border-color: #777; }
        .confirmation-dialog p {
            margin-top: 0;
        }
        .confirmation-buttons {
            display: flex;
            gap: 10px;
        }
        .confirm-btn, .cancel-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .confirm-btn {
            background-color: var(--error-color);
            color: white;
        }
        .cancel-btn {
            background-color: #ccc;
        }
        .email-list {
            list-style-type: none;
            padding: 0;
        }
        .email-item {
            border-bottom: 1px solid #eee;
            padding: 10px 0;
        }
        .email-item:last-child {
            border-bottom: none;
        }
        .email-sender {
            font-weight: bold;
        }
        .email-subject {
            color: #555;
        }
        .email-date {
            color: #888;
            font-size: 0.9em;
            margin-top: 2px;
        }
        [data-theme="dark"] .email-subject { color: #ccc; }
        [data-theme="dark"] .email-date { color: #888; }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        .stat-card {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
        }
        [data-theme="dark"] .stat-card { background: #1b1b1b; }
        .stat-card h3 {
            margin-top: 0;
        }
        /* About section link color matches theme (avoid purple visited) */
        .about-card a,
        .about-card a:visited {
            color: var(--primary-color);
        }

        /* Loading Screen Styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(2px);
        }

        .loading-container {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .stats-loading {
            max-width: 500px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-container h3 {
            margin: 0 0 10px 0;
            color: var(--text-color);
            font-size: 1.3em;
        }

        .loading-container p {
            margin: 0 0 20px 0;
            color: var(--text-secondary);
            font-size: 1em;
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), #4a90e2);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        #progressText, #statsProgressText {
            font-weight: 600;
            color: var(--text-color);
            min-width: 40px;
        }

        .stats-details {
            margin-top: 20px;
            text-align: left;
        }

        .stats-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .stats-step.active {
            opacity: 1;
            color: var(--primary-color);
        }

        .stats-step.completed {
            opacity: 0.8;
            color: #28a745;
        }

        .step-icon {
            font-size: 1.2em;
            width: 24px;
            text-align: center;
        }

        .step-text {
            font-size: 0.95em;
            color: var(--text-secondary);
        }

        .stats-step.active .step-text,
        .stats-step.completed .step-text {
            color: inherit;
        }

        /* Light theme adjustments */
        [data-theme="light"] .loading-overlay {
            background: rgba(248, 248, 248, 0.98);
        }

        [data-theme="light"] .loading-container {
            background: #ffffff !important;
            border: 1px solid #d0d0d0 !important;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
        }

        [data-theme="light"] .loading-spinner {
            border: 4px solid #e0e0e0 !important;
            border-top: 4px solid var(--primary-color) !important;
        }

        [data-theme="light"] .progress-bar {
            background: #e0e0e0 !important;
        }

        /* Dark theme adjustments */
        [data-theme="dark"] .loading-overlay {
            background: rgba(0, 0, 0, 0.4);
        }

        [data-theme="dark"] .loading-container {
            background: #1a1a1a;
            border-color: #333;
        }

        /* Mobile responsive styles for loading screens - Updated 2025-09-04 */
        @media screen and (max-width: 768px) {
            .loading-overlay .loading-container {
                margin-left: 10px !important;
                margin-right: 10px !important;
                width: calc(100% - 20px) !important;
                max-width: none !important;
            }
            
            .loading-overlay {
                justify-content: flex-start !important;
                padding: 0 !important;
            }
            
            .loading-container h3 {
                font-size: 1.2em;
                margin-bottom: 15px;
            }
            
            .loading-container p {
                font-size: 0.95em;
                margin-bottom: 20px;
            }
            
            .loading-steps {
                gap: 12px;
                margin-bottom: 20px;
            }
            
            .loading-step {
                padding: 10px 14px;
                font-size: 0.9em;
            }
            
            .loading-step .step-icon {
                width: 18px;
                height: 18px;
                font-size: 0.8em;
            }
            
            .loading-step .step-text {
                font-size: 0.85em;
            }
            
            .fun-fact {
                font-size: 0.9em;
                padding: 12px;
                margin: 15px 0;
            }
            
            .loading-spinner {
                width: 35px;
                height: 35px;
                margin: 15px auto;
            }
        }

        @media screen and (max-width: 480px) {
            .loading-overlay .loading-container {
                margin-left: 5px !important;
                margin-right: 5px !important;
                width: calc(100% - 10px) !important;
            }
            
            .loading-overlay {
                justify-content: flex-start !important;
                padding: 0 !important;
            }
            
            .loading-container h3 {
                font-size: 1.1em;
                margin-bottom: 12px;
            }
            
            .loading-container p {
                font-size: 0.9em;
                margin-bottom: 15px;
            }
            
            .loading-steps {
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .loading-step {
                padding: 8px 12px;
                font-size: 0.85em;
            }
            
            .fun-fact {
                font-size: 0.85em;
                padding: 10px;
                margin: 12px 0;
            }
        }
        /* Make compose inputs slightly narrower to avoid edge overflow */
        #compose-form input,
        #compose-form textarea {
            width: 98%;
            box-sizing: border-box;
        }
        /* Desktop-specific adjustment so Undo title sits correctly in its box */
        @media (min-width: 769px) {
            .stat-card.undo-card { padding-top: 48px; }
            .stat-card.undo-card h3 { margin: 0 0 12px; line-height: 1.3; }
            /* Lower the Email Statistics title slightly on desktop */
            .stat-card .stats-title { margin-top: 6px !important; }
            /* Lower the Compose Email title slightly on desktop */
            .stat-card .compose-title { margin-top: 6px !important; }
        }
        .stat-list {
            list-style-type: none;
            padding: 0;
        }
        [data-theme="dark"] .stat-list { color: #ccc; }
        .bar-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .bar-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }
        .bar-label {
            width: 84px;
            font-size: 0.9em;
            color: #333;
            flex-shrink: 0;
        }
        .bar-label-wide {
            width: 180px;
            font-size: 0.9em;
            color: #333;
            flex-shrink: 0;
            overflow: hidden;
        }
        [data-theme="dark"] .bar-label, [data-theme="dark"] .bar-label-wide { color: #ccc; }
        /* Remove unused suggestions grid styles */
        .bar-track {
            background: #eee;
            flex: 1;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
        }
        [data-theme="dark"] .bar-track { background: #333; }
        [data-theme="dark"] input, [data-theme="dark"] textarea, [data-theme="dark"] select { background-color: #121212; color: var(--text-color); border-color: #444; }

        /* Theme toggle */
        .theme-switch { margin-top: 8px; display: inline-block; }
        .theme-toggle-btn { cursor: pointer; border: 1px solid #ccc; border-radius: 999px; padding: 4px 8px; background: #fff; color: #333; display: inline-flex; align-items: center; gap: 10px; }
        .theme-toggle-btn:hover { background: #f0f0f0; }
        [data-theme="dark"] .theme-toggle-btn { background: #1e1e1e; color: #e6e6e6; border-color: #444; }
        [data-theme="dark"] .theme-toggle-btn:hover { background: #2a2a2a; }
        .switch-track { position: relative; width: 60px; height: 30px; background: #ececec; border-radius: 999px; display: inline-flex; align-items: center; justify-content: space-between; padding: 0 10px; box-sizing: border-box; overflow: hidden; }
        .switch-icon { width: 16px; height: 16px; color: #9aa0a6; display: inline-flex; align-items: center; justify-content: center; z-index: 2; position: relative; }
        .switch-icon.sun { color: #ffffff; margin-left: -3px; }
        .switch-icon.moon { color: #9aa0a6; margin-right: -3px; }
        .switch-icon svg { width: 16px; height: 16px; stroke: currentColor; fill: none; stroke-width: 1.8; stroke-linecap: round; stroke-linejoin: round; }

        .switch-icon.moon { color: #9aa0a6; }
        .switch-thumb { position: absolute; top: 4px; left: 4px; width: 22px; height: 22px; background: var(--primary-color); border-radius: 50%; box-shadow: 0 1px 4px rgba(0,0,0,0.25); transition: left .18s ease; z-index: 1; }
        .switch-track::before { content: ''; position: absolute; top: 4px; left: 4px; width: 22px; height: 22px; background: rgba(59, 130, 246, 0.15); border-radius: 50%; transition: left .18s ease; z-index: 0; }
        [data-theme="dark"] .switch-track { background: #333; }
        [data-theme="dark"] .switch-thumb { left: calc(100% - 26px); background: var(--primary-color); }
        [data-theme="dark"] .switch-track::before { left: calc(100% - 26px); }
        [data-theme="dark"] .switch-icon.moon { color: #ffffff; }
        
        /* Hebrew RTL switch fix - handled by JavaScript */
        html[lang="he"] .switch-track { direction: ltr; }
        .bar-fill {
            height: 100%;
            background: var(--primary-color);
        }
        .pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-radius: 999px;
            background: #f1f3f4;
            color: #202124;
            white-space: nowrap;
        }
        [data-theme="dark"] .pill { background: #666; color: #fff; }
        .pill-swatch {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        /* Ensure long quick-command pills don't overflow and X stays clickable */
        .fav-item { 
            max-width: 100%; 
            min-width: 0; 
            margin-bottom: 8px;
        }
        .fav-item:last-child {
            margin-bottom: 0;
        }
        
        /* Fix pill spacing in favorites list */
        /* Desktop (PC): column-first grid (4 rows), columns keep compact widths */
        @media (min-width: 769px) {
            #favorites-list {
                display: grid;
                grid-auto-flow: column;                    /* fill down first */
                grid-template-rows: repeat(4, max-content); /* up to 4 rows */
                grid-auto-columns: minmax(240px, 320px);    /* compact column width */
                justify-content: start;                     /* don't stretch to full width */
                gap: 8px 12px;
                margin-top: 10px;
                max-width: 1024px;                          /* cap total width so 1-3 cols stay short */
            }
            #favorites-list li { margin: 0; }
            .fav-item { width: 100%; }
            /* Keep space for the X so it never clips, especially in 3-column layout */
            .fav-item .pill { flex: 1 1 auto; max-width: calc(100% - 44px); }
            .fav-item .cancel-btn { padding: 2px 6px; }
        }

        /* Wider desktops (typically 3 columns): make pills slightly smaller */
        @media (min-width: 1200px) {
            #favorites-list {
                grid-auto-columns: minmax(200px, 260px);
                max-width: 900px; /* encourage 3 compact columns */
            }
            .fav-item .pill { padding: 5px 8px; }
            .fav-item .cancel-btn { padding: 2px 6px; }
        }

        /* Mobile: 2 columns */
        @media (max-width: 768px) {
            #favorites-list {
                display: grid;
                grid-template-columns: 1fr; /* 1 column on mobile */
                gap: 8px;
            }
            #favorites-list li { margin: 0; }
        }

        /* Ensure no leftover margins from previous rules */
        #favorites-list li { margin: 0; }
        
        /* PC-only: Move Quick Commands title and pills higher */
        @media (min-width: 769px) {
            /* Lower the "Your Labels" title specifically - PC only - more aggressive */
            .results .stat-card h3 {
                margin-top: -20px !important;
            }
            /* Force the Hebrew title positioning with maximum specificity */
            html[lang="he"] .results .stat-card h3,
            html[dir="rtl"] .results .stat-card h3,
            .results .stat-card h3:not([style*="margin-top: 0"]) {
                margin-top: -20px !important;
            }
            /* Nuclear option - target any h3 in results stat-card */
            .results .stat-card > h3 {
                margin-top: -20px !important;
            }
            /* Other stat-card h3 elements (not in results) */
            .stat-card h3 {
                margin-top: -36px !important;
            }
            #favorites-list {
                margin-top: 2px !important;
            }
        }
        .fav-item .pill {
            min-width: 0;
            flex: 1 1 0%;              /* take remaining space, allow shrink */
            max-width: none;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* Ensure the pill text truncates instead of overflowing offscreen */
        .fav-item .pill code {
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            vertical-align: bottom;
        }
        #favorites-list { overflow-x: hidden; }
        #favorites-list li { min-width: 0; }
        .fav-item .cancel-btn { flex-shrink: 0; }
        .error-message {
            color: var(--error-color);
            padding: 15px;
            border: 1px solid var(--error-color);
            background-color: #f2dede;
            border-radius: 4px;
        }
        .example-commands {
            margin-top: 20px;
        }
        .example-commands h3 {
            margin-bottom: 10px;
        }
        .example-commands ul {
            padding-left: 20px;
            color: #666;
        }
        [data-theme="dark"] .example-commands ul { color: #ccc; }
        /* RTL: adjust padding so list is slightly pushed to the right */
        html[dir="rtl"] .example-commands ul {
            padding-right: 24px;
            padding-left: 8px;
        }
        
        /* Hebrew PC: make example commands use normal UI font/style (not code/monospace) */
        html[lang="he"] .example-commands ul li code {
            font-size: 1.05em; /* slightly smaller */
            font-style: normal;
            font-family: inherit;
            font-weight: 400;
        }
        /* Mobile English: tighter spacing between example command lines */
        @media (max-width: 768px) {
            /* Nudge example commands closer to the edge on mobile */
            html[dir="ltr"] .example-commands { margin-left: -12px; }
            html[dir="rtl"] .example-commands { margin-right: -12px; }
            html[dir="ltr"] .example-commands ul li { margin: 4px 0; }
            /* Hebrew mobile: keep commands on one line and nudge size */
            html[dir="rtl"] .example-commands ul li code {
                white-space: nowrap;
                display: inline-block;
                letter-spacing: -0.25px;
                font-size: 0.95em;
            }
            /* Ensure the specific long label example stays on one line with local scroll */
            html[dir="ltr"] .example-commands ul li.long-label-example code {
                white-space: nowrap;
                display: inline-block;
                letter-spacing: -0.2px;
                font-size: 0.9em; /* final nudge smaller only for this long item */
            }
            /* Keep other long EN examples (archive/delete) on one line and make them fit */
            html[dir="ltr"] .example-commands ul li.long-example code {
                white-space: nowrap;
                display: inline-block;
                letter-spacing: -0.35px; /* tighter spacing to fit */
                font-size: 0.82em;       /* slightly smaller text on mobile */
            }
            /* Promotions long example: keep in one line with tighter spacing */
            html[dir="ltr"] .example-commands ul li.long-promo-example { 
                list-style-type: disc; 
                list-style-position: outside;
                padding-left: 0;
            }
            html[dir="ltr"] .example-commands ul li.long-promo-example code {
                white-space: nowrap; 
                display: inline-block;
                letter-spacing: -0.2px;
                font-size: 0.85em;
            }
        }
        @media (max-width: 480px) {
            html[dir="ltr"] .example-commands ul li.long-example code {
                letter-spacing: -0.55px;
                font-size: 0.76em;
            }
        }
        /* Mobile English-only: show shorter variants for specific long examples */
        .ex-en-mobile { display: none; }
        .ex-en-desktop { display: inline; }
        @media (max-width: 768px) {
            html[dir="ltr"] .ex-en-desktop { display: none; }
            html[dir="ltr"] .ex-en-mobile { display: inline; }
        }
        
        /* Dark-mode overrides for inline-styled elements */
        [data-theme="dark"] details > summary { color: #ccc !important; }
        [data-theme="dark"] details > div { color: #ccc !important; }
        [data-theme="dark"] .bar-item > div[style*="text-align:right"] { color: #ccc !important; }
        [data-theme="dark"] details.stat-card div { color: #ccc !important; }
        [data-theme="dark"] [style*="color:#555"] { color: #ccc !important; }
        [data-theme="dark"] [style*="color:#666"] { color: #ccc !important; }
        [data-theme="dark"] [style*="color:#777"] { color: #ccc !important; }
        [data-theme="dark"] [style*="color:#888"] { color: #ccc !important; }
        [data-theme="dark"] [style*="color:#999"] { color: #ccc !important; }
        
        /* Additional dark-mode overrides for specific sections */
        [data-theme="dark"] .stat-card summary { color: #ccc !important; }
        [data-theme="dark"] .stat-card details > div { color: #ccc !important; }
        [data-theme="dark"] .stat-card details > p { color: #ccc !important; }
        [data-theme="dark"] .stat-card h4 { color: #fff !important; }
        [data-theme="dark"] .stat-card .stat-list li { color: #eee !important; }
        [data-theme="dark"] .stat-card .bar-list li { color: #eee !important; }
        [data-theme="dark"] .stat-card .bar-label { color: #eee !important; }
        
        /* PC and mobile stats list styling */
        .stats-grid .stat-list li {
            background: #f0f0f0;
            border-radius: 4px;
            padding: 4px 8px;
            margin-bottom: 3px;
            font-size: 0.9em;
            word-break: break-word;
        }
        
        [data-theme="dark"] .stats-grid .stat-list li {
            background: #333;
            color: #fff;
        }
        .all-commands {
            margin-top: 20px;
        }
        .all-commands-toggle {
            cursor: pointer;
            font-weight: bold;
            color: var(--primary-color);
        }
        .all-commands-list {
            display: none; /* Hidden by default */
            margin-top: 10px;
            padding-left: 20px;
            list-style-type: none;
        }
        .all-commands-list li {
            margin-bottom: 8px;
            padding: 8px 12px;
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: box-shadow 0.2s ease;
        }
        .all-commands-list li:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        .all-commands-list li b {
            color: var(--primary-color);
        }
        .autocomplete-suggestions {
            border: 1px solid #ddd;
            border-top: none;
            max-height: 150px;
            overflow-y: auto;
            background-color: #fff;
            position: absolute;
            width: calc(100% - 42px); /* Adjust based on form padding/border */
            z-index: 1000;
        }
        
        /* RTL support for autocomplete suggestions */
        [dir="rtl"] .autocomplete-suggestions {
            text-align: right;
        }
        [data-theme="dark"] .autocomplete-suggestions { background-color: #1e1e1e; border-color: #444; }
        [data-theme="dark"] .autocomplete-suggestions div:hover { background-color: #2a2a2a; }
        /* Mobile-only: slightly smaller suggestion text in quick command bar */
        @media (max-width: 768px) {
            .autocomplete-suggestions { font-size: 0.88em; }
            .autocomplete-suggestions div { font-size: 0.88em; }
        }
        .autocomplete-suggestions div {
            padding: 10px;
            cursor: pointer;
        }
        .autocomplete-suggestions div:hover {
            background-color: #f0f0f0;
        }
        .autocomplete-suggestions div.active {
            background-color: #e8f0fe;
        }
        [data-theme="dark"] .autocomplete-suggestions div.active { background-color: #2f2f2f; color: var(--text-color); }


        .contact-suggestions {
            border: 1px solid #ddd;
            border-top: none;
            max-height: 220px;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #fff;
            position: absolute;
            z-index: 1100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            border-radius: 0 0 6px 6px;
        }
        [data-theme="dark"] .contact-suggestions { background-color: #1e1e1e; border-color: #444; }
        [data-theme="dark"] .contact-suggestions div:hover { background-color: #2a2a2a; }
        .contact-suggestions div { padding: 10px; cursor: pointer; display:flex; align-items:center; justify-content:space-between; gap:8px; }
        .contact-suggestions div:hover { background-color: #f0f0f0; }
        .contact-suggestions div.active { background-color: #e8f0fe; }
        [data-theme="dark"] .contact-suggestions div.active { background-color: #2f2f2f; color: var(--text-color); }
        .contact-remove { color:#a00; font-weight:700; padding:0 6px; cursor:pointer; }
        .contact-remove:hover { color:#d00; }
        .contact-suggestions .contact-text { flex:1; min-width:0; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; direction:ltr; }

        /* Quick Commands inline autocomplete suggestion */
        .fav-inline-suggestion {
            position: absolute;
            pointer-events: none;
            color: #999;
            font-size: 14px;
            font-family: inherit;
            line-height: 1.2;
            padding: 0;
            border: none;
            background: transparent;
            z-index: 1000;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            word-wrap: break-word;
        }
        /* Hebrew-only: make Quick Commands inline autocomplete smaller and adjust vertical position */
        html[lang="he"] .fav-inline-suggestion { font-size: 12px !important; top: 7px !important; }
        [data-theme="dark"] .fav-inline-suggestion {
            color: #666;
        }
        .command-form {
            position: relative; /* Needed for absolute positioning of suggestions */
            align-items: flex-start;
        }
        .snackbar {
            visibility: hidden;
            min-width: 240px;
            max-width: 90vw;
            background-color: #323232;
            color: #fff;
            text-align: left;
            border-radius: 4px;
            padding: 12px 16px;
            position: fixed;
            left: 50%;
            bottom: 24px;
            transform: translateX(-50%);
            z-index: 3000;
            box-shadow: 0 6px 18px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity .25s ease, bottom .25s ease;
        }
        .snackbar.show { visibility: visible; opacity: 1; bottom: 32px; }
        .snackbar.success { background-color: var(--success-color); }
        .snackbar.error { background-color: var(--error-color); }
        .snackbar.info { background-color: #4285f4; }
        .snackbar a { color: #fff; text-decoration: underline; margin-left: 10px; }
        .results.highlight {
            animation: flashHighlight 1.2s ease;
        }
        @keyframes flashHighlight {
            0% { box-shadow: 0 0 0 0 rgba(74,144,226,0.6); }
            50% { box-shadow: 0 0 0 6px rgba(74,144,226,0.15); }
            100% { box-shadow: 0 0 0 0 rgba(74,144,226,0); }
        }
        @media (min-width: 600px) {
            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        /* Quick Commands - PC version */
        .quick-commands-buttons input {
            min-width: 220px;
        }
        
        /* Quick Commands - PC version button positioning */
        /* English version - restore to perfect positioning */
        .quick-commands-buttons #clear-fav-form .cancel-btn {
            transform: translateX(4px);
        }
        
        /* Hebrew version - adjust for RTL layout */
        html[lang="he"] .quick-commands-buttons #clear-fav-form .cancel-btn {
            transform: translateX(1px);
        }
        
        /* Mobile-specific fixes */
        @media (max-width: 768px) {
            .command-form {
                flex-direction: column;
                gap: 10px;
            }
            
            #command-input {
                width: 100%;
                box-sizing: border-box;
            }
            
            /* Mobile: smaller padding for command cards */
            .all-commands-list li {
                padding: 6px 10px;
                margin-bottom: 6px;
                font-size: 0.9em;
            }
            
            #command-submit {
                width: 100%;
                padding: 12px 20px;
            }
            
            /* Mobile Quick Commands autocomplete fixes */
            .fav-inline-suggestion {
                font-size: 17px !important; /* Larger font for mobile */
                line-height: 1.4 !important; /* Better line height for mobile */
                top: 5px !important; /* Better vertical alignment on mobile */
            }
            /* English-only mobile: slightly smaller than default */
            html[dir="ltr"] .fav-inline-suggestion { font-size: 16px !important; }
            /* Hebrew-only mobile: 1px larger, adjust slightly higher */
            html[lang="he"] .fav-inline-suggestion { font-size: 16px !important; top: 5px !important; }
            
            .quick-commands-buttons {
                display: flex;
                gap: 8px;
                flex-wrap: nowrap;
                align-items: center;
            }
            
            .quick-commands-buttons .cancel-btn {
                padding: 8px 16px;
                font-size: 0.9em;
                min-width: auto;
                flex-shrink: 0;
            }
            
            .quick-commands-buttons form {
                flex: 2;
                min-width: 0;
            }
            
            .quick-commands-buttons input {
                width: 100%;
                box-sizing: border-box;
                padding: 12px 16px;
                font-size: 1em;
                min-width: 250px;
            }
            
            .quick-commands-buttons .cancel-btn[form="add-fav-form"] {
                margin-left: -15px;
            }
            
            .quick-commands-buttons #clear-fav-form .cancel-btn {
                transform: translateX(15px);
            }
            
            /* Hebrew mobile adjustments */
            html[lang="he"] .quick-commands-buttons .cancel-btn[form="add-fav-form"] {
                margin-left: -6px;
            }
            
            html[lang="he"] .quick-commands-buttons #clear-fav-form .cancel-btn {
                transform: translateX(-1px);
            }
            
            /* Hebrew mobile: tighter spacing between example command lines */
            html[dir="rtl"] .example-commands ul li { margin: 4px 0; }
            /* Ensure the specific long Hebrew command stays on one line */
            html[dir="rtl"] .example-commands ul li.long-hebrew-example code {
                white-space: nowrap;
                display: inline-block;
                letter-spacing: -0.4px; /* Tighter spacing to make it fit */
            }
            
            /* Mobile label distribution bar improvements */
            .bar-track {
                min-width: 60px; /* Ensure bars have a minimum width on mobile */
                height: 16px; /* Slightly taller bars on mobile */
                border-radius: 8px; /* Adjusted border radius for taller bars */
            }
            
            .bar-fill {
                min-width: 8px; /* Ensure even very small percentages show as a small bar, not a circle */
            }
            
            /* Mobile bar layout adjustments to prevent overflow */
            .bar-item {
                gap: 6px; /* Reduce gap between elements on mobile */
            }
            
            .bar-label-wide {
                width: 140px; /* Reduce label width on mobile to make room for bars */
                font-size: 0.85em; /* Slightly smaller font to fit better */
            }
            
            .bar-item > div[style*="text-align:right"] {
                width: 32px !important; /* Reduce count column width on mobile */
                font-size: 0.8em; /* Smaller font for counts on mobile */
            }
            
            /* Mobile insights improvements */
            .stat-card h4 + ul {
                padding-left: 0; /* Remove default list padding on mobile */
            }
            
            .stat-card h4 + ul li {
                background: #f8f9fa; /* Light background for better readability */
                border-radius: 6px; /* Rounded corners */
                padding: 8px 12px; /* Comfortable padding */
                margin-bottom: 6px; /* Space between insights */
                font-size: 0.9em; /* Slightly smaller font for mobile */
                line-height: 1.4; /* Better line spacing */
                word-wrap: break-word; /* Break long words */
                overflow-wrap: break-word; /* Additional word breaking */
                max-width: 100%; /* Prevent overflow */
                box-sizing: border-box; /* Include padding in width calculation */
            }
            
            [data-theme="dark"] .stat-card h4 + ul li {
                background: #2a2a2a; /* Dark background for dark theme */
                color: #e6e6e6; /* Light text for dark theme */
            }
            
            /* Mobile stats - shorter boxes and light mode styling */
            .stats-grid .stat-list li {
                background: #f0f0f0 !important;
                border-radius: 4px !important;
                padding: 4px 8px !important;
                margin-bottom: 3px !important;
                font-size: 0.85em !important;
                max-width: 90% !important;
                word-break: break-word !important;
            }
            
            [data-theme="dark"] .stats-grid .stat-list li {
                background: #333 !important;
                color: #fff !important;
            }
        }
    </style>
</head>
<body data-i18n-view-details="{% trans 'View details' %}"
      data-i18n-loading="{% trans 'Loading…' %}"
      data-i18n-no-more-results="{% trans 'No more results' %}"
      data-i18n-load-more="{% trans 'Load more' %}"
      data-i18n-analyzing="{% trans 'Analyzing...' %}"
      data-i18n-undoing="{% trans 'Undoing...' %}"
      data-i18n-loaded-more-with-count="{% trans 'Loaded {count} more' %}"
      data-i18n-failed-load-more="{% trans 'Failed to load more' %}"
      data-i18n-confirm-clear-favorites="{% trans 'Clear all favorites?' %}">
    <div id="loading-overlay" class="overlay" aria-hidden="true">
        <div class="overlay-content">
            <div class="spinner" aria-hidden="true"></div>
            <div>{% trans "Processing…" %}</div>
        </div>
    </div>
    <div id="snackbar" class="snackbar" role="status" aria-live="polite"></div>
    <div class="container">
        <header>
            <h1>{% trans "Email AI Agent" %}</h1>
            <form action="{% url 'set_language' %}" method="post" style="margin-top:8px;">
                {% csrf_token %}
                <input type="hidden" name="next" value="{{ request.get_full_path }}">
                {% get_current_language as LANGUAGE_CODE %}
                {% get_available_languages as LANGUAGES %}
                <label for="language-select" style="font-size:0.9em;">{% trans "Language" %}:</label>
                <select id="language-select" name="language" onchange="this.form.submit()" style="padding:6px 8px;border:1px solid #ccc;border-radius:4px;">
                    {% for lang in LANGUAGES %}
                    <option value="{{ lang.0 }}" {% if lang.0 == LANGUAGE_CODE %}selected{% endif %}>{{ lang.1 }}</option>
                    {% endfor %}
                </select>
            </form>
            <div class="theme-switch">
                <button id="theme-toggle" type="button" class="theme-toggle-btn" aria-label="Toggle theme">
                    <span class="switch-track">
                        <span class="switch-icon sun" aria-hidden="true">
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <circle cx="12" cy="12" r="4"/>
                                <path d="M12 2v2M12 20v2M4 12H2M22 12h-2M5 5l-1.5-1.5M20.5 20.5L19 19M5 19l-1.5 1.5M20.5 3.5L19 5"/>
                            </svg>
                        </span>
                        <span class="switch-icon moon" aria-hidden="true">
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                            </svg>
                        </span>
                        <span class="switch-thumb"></span>
                    </span>
                </button>
            </div>
        </header>
        <main>
            
            {% if not is_agent_ready %}
                <div class="error-message">
                    <strong>{% trans 'Connection Error:' %}</strong> {{ error_message }}
                </div>
            {% else %}
                <form method="post" class="command-form" id="command-form" autocomplete="off">
                    {% csrf_token %}
                    <input type="text" id="command-input" name="command" dir="auto" placeholder="{% trans 'e.g., list recent emails' %}" autofocus autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                    <button type="submit" id="command-submit">{% trans 'Process' %}</button>
                </form>
                {% if show_compose %}
                <div class="stat-card" style="margin-bottom:16px;">
                    <h3 class="compose-title" style="margin-top:0;">{% trans 'Compose Email' %}</h3>
                    <form method="post" id="compose-form" style="display:grid; gap:10px;">
                        {% csrf_token %}
                        <input type="hidden" name="compose_send" value="1">
                        <label>
                            <div style="font-weight:600; margin-bottom:4px;">{% trans 'To' %}</div>
                            <input name="compose_to" type="email" style="width:100%; padding:8px; border:1px solid #ccc; border-radius:4px;" required placeholder="name@example.com" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                        </label>
                        <label>
                            <div style="font-weight:600; margin-bottom:4px;">{% trans 'Subject' %}</div>
                            <input name="compose_subject" type="text" style="width:100%; padding:8px; border:1px solid #ccc; border-radius:4px;" placeholder="{% trans 'Subject (optional)' %}" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                        </label>
                        <label>
                            <div style="font-weight:600; margin-bottom:4px;">{% trans 'Message' %}</div>
                            <textarea name="compose_body" rows="8" style="width:100%; padding:8px; border:1px solid #ccc; border-radius:4px;" placeholder="{% trans 'Write your message...' %}"></textarea>
                        </label>
                        <div>
                            <button type="submit" class="cancel-btn" style="background:#4a90e2;color:#fff;">{% trans 'Send' %}</button>
                        </div>
                    </form>
                </div>
                {% endif %}
                <form method="post" style="display:flex; align-items:center; gap:8px; margin:-10px 0 12px 0;">
                    {% csrf_token %}
                    <label for="per_page" style="font-size:0.9em;color:#555;">{% trans 'Results per page:' %}</label>
                    <select name="per_page" id="per_page" onchange="this.form.submit()" style="padding:6px 8px;border:1px solid #ccc;border-radius:4px;">
                        <option value="10" {% if per_page == 10 %}selected{% endif %}>10</option>
                        <option value="25" {% if per_page == 25 %}selected{% endif %}>25</option>
                        <option value="50" {% if per_page == 50 %}selected{% endif %}>50</option>
                        <option value="100" {% if per_page == 100 %}selected{% endif %}>100</option>
                    </select>
                </form>

                <div class="stat-card" style="margin-bottom:16px;">
                    <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;">
                        <h3 style="margin:0;">{% trans 'Quick Commands' %}</h3>
                        <div class="quick-commands-buttons" style="display:flex;flex-direction:column;gap:8px;">
                            <form method="post" id="add-fav-form" style="display:flex;gap:8px;align-items:center;">
                                {% csrf_token %}
                                <input type="hidden" name="add_favorite" value="1">
                                <input type="text" name="fav_command" id="fav-input" placeholder="{% trans 'Save custom command' %}" style="padding:6px 8px;border:1px solid #ccc;border-radius:4px;" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
                            </form>
                            <div style="display:flex;justify-content:flex-start;align-items:center;gap:40px;">
                                <button type="submit" form="add-fav-form" class="cancel-btn" style="background:#4a90e2;color:#fff;">{% trans 'Add Favorite' %}</button>
                                <form method="post" id="clear-fav-form" style="margin:0;">
                                    {% csrf_token %}
                                    <input type="hidden" name="clear_favorites" value="1">
                                    <button type="submit" class="cancel-btn" style="background:#d9534f;color:#fff;">{% trans 'Clear all' %}</button>
                                </form>
                            </div>
                        </div>
                    </div>
                    {% if favorite_commands %}
                    <ul class="stat-list" id="favorites-list" style="margin-top:10px;">
                        {% for fc in favorite_commands %}
                        <li>
                            <form method="post" class="fav-item" style="display:flex;align-items:center;gap:6px;width:100%;">
                                {% csrf_token %}
                                <input type="hidden" name="fav_command" value="{{ fc }}">
                                <button type="button" class="pill" title="{{ fc }}" onclick='insertCommand("{{ fc|escapejs }}")'>{{ fc }}</button>
                                <input type="hidden" name="remove_favorite" value="1">
                                <button type="submit" class="cancel-btn" title="{% trans 'Remove' %}" style="padding:4px 8px;">×</button>
                            </form>
                        </li>
                        {% endfor %}
                    </ul>
                    {% else %}
                    <p style="color:#666;margin-top:10px;">{% trans 'No favorites yet. Add one above.' %}</p>
                    {% endif %}
                </div>

                {% if confirmation_message %}
                <div class="confirmation-dialog">
                    <p><strong>{% trans 'Confirmation Required:' %}</strong> {{ confirmation_message }}</p>
                    {% if result.preview %}
                    <div style="margin:10px 0;">
                        <div style="font-weight:600; margin-bottom:6px;">{% trans 'Preview (first 10)' %}</div>
                        <ul class="email-list">
                            {% for p in result.preview %}
                            <li class="email-item">
                                <div class="email-sender" dir="auto">{{ p.sender }}</div>
                                <div class="email-subject" dir="auto">{{ p.subject }}</div>
                                {% if p.date %}<div style="color:#666; font-size:0.85em;">{{ p.date }}</div>{% endif %}
                            </li>
                            {% endfor %}
                        </ul>
                        {% if result.total_estimated %}
                        <div style="color:#666; font-size:0.9em; margin-top:6px;">{% trans 'Estimated total affected:' %} {{ result.total_estimated }}</div>
                        {% endif %}
                    </div>
                    {% endif %}
                    <form method="post" id="confirm-form">
                        {% csrf_token %}
                        <input type="hidden" name="confirmation_data" value="{{ confirmation_data }}">
                        <div class="confirmation-buttons">
                            <button type="submit" class="confirm-btn" id="confirm-btn">{% trans 'Confirm' %}</button>
                            <a href="{% url 'index' %}" class="cancel-btn">{% trans 'Cancel' %}</a>
                        </div>
                    </form>
                </div>
                {% endif %}

                <div class="results">
                    {% if result %}
                        {% if result.status == 'success' %}
                            <div class="success-message">{{ result.message }}</div>
                            {% if result.type == 'email_list' and result.data %}
                                <ul class="email-list" id="email-list">
                                {% for email in result.data %}
                                    <li class="email-item">
                                        <div class="email-sender" dir="auto">{{ email.sender }}</div>
                                        <div class="email-subject" dir="auto">{{ email.subject }}</div>
                                        {% if email.date %}
                                        <div class="email-date">{{ email.date }}</div>
                                        {% endif %}
                                    </li>
                                {% endfor %}
                                </ul>
                                {% if result.next_page_token %}
                                <form method="post" id="load-more-form">
                                    {% csrf_token %}
                                    <input type="hidden" name="load_more" value="1">
                                    <input type="hidden" name="load_more_token" id="load_more_token" value="{{ result.next_page_token }}">
                                    <input type="hidden" name="list_context" id="list_context" value='{{ result.list_context_json|default:"" }}'>
                                    <button type="submit" id="load-more-btn">{% trans 'Load more' %}</button>
                                    <span id="load-more-inline" style="display:none;margin-left:8px;">{% trans 'Loading…' %}</span>
                                </form>
                                {% endif %}
                            {% elif result.type == 'label_list' and result.data %}
                                <div class="stat-card">
                                    <h3>{% trans 'Your Labels' %}</h3>
                                    <ul class="stat-list">
                                        {% for label in result.data %}
                                        <li>{{ label.name }}</li>
                                        {% endfor %}
                                    </ul>
                                </div>
                            {% endif %}
                        {% elif result.status == 'error' %}
                            <div class="error-message">
                                <p>{{ result.message }}</p>
                                {% if result.debug_info %}
                                <pre style="font-size: 0.8em; margin-top: 10px;">Debug Info: {{ result.debug_info }}</pre>
                                {% endif %}
                            </div>
                        {% elif result.status == 'info' %}
                            <div class="info-message">{{ result.message }}</div>
                        {% elif result.total_inbox is not None %}
                            <div class="stat-card">
                                <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
                                    <h3 class="stats-title" style="margin:0;">{% trans 'Email Statistics' %}</h3>
                                    <button type="button" id="full-stats-btn" class="cancel-btn" style="background:#4a90e2;color:#fff;">{% trans 'Full analysis' %}</button>
                                </div>
                                <p><strong>{% trans 'Total Inbox Emails:' %}</strong> {{ result.total_inbox }}</p>
                                <p><strong>{% trans 'Sample Analyzed:' %}</strong> {{ result.sample_analyzed }} {% if result.analysis_scope == 'full' %}({% trans 'full' %}){% else %}({% trans 'sample' %}){% endif %}
                                <details style="margin-top:6px;">
                                    <summary style="cursor:pointer;color:#555;">{% trans 'What is "sample analyzed"?' %}</summary>
                                    <div style="margin-top:6px;color:#666;">{% trans 'Number of recent emails examined to compute stats quickly. Choose "Full analysis" to analyze all emails.' %}</div>
                                </details></p>
                                
                                {% if result.analysis_limited %}
                                <div style="background:#fff3cd; border:1px solid #ffeaa7; border-radius:4px; padding:12px; margin:12px 0; color:#856404;">
                                    <strong>📊 {% trans 'Analysis Note:' %}</strong> {{ result.analysis_limit_note }}
                                </div>
                                {% endif %}
                                <div class="stats-grid">
                                    <div>
                                        <h4>{% trans 'Top Senders' %}</h4>
                                        <ul class="stat-list">
                                            {% for sender, count in result.top_senders %}
                                            <li dir="auto">{{ sender }}: {{ count }}</li>
                                            {% endfor %}
                                        </ul>
                                    </div>
                                    <div>
                                        <h4>{% trans 'Top Domains' %}</h4>
                                        <ul class="stat-list">
                                            {% for domain, count in result.top_domains %}
                                            <li>{{ domain }}: {{ count }}</li>
                                            {% endfor %}
                                        </ul>
                                    </div>
                                </div>
                                <div class="stats-grid" style="margin-top:12px;">
                                    <div>
                                        <h4>{% trans 'Top Subject Terms' %}</h4>
                                        <ul class="stat-list">
                                            {% for term, count in result.top_subject_terms %}
                                            <li>{{ term }}: {{ count }}</li>
                                            {% endfor %}
                                        </ul>
                                    </div>
                                    <div>
                                        <h4>{% trans 'Emails by Hour' %}</h4>
                                        <details>
                                            <summary style="cursor:pointer;color:#555;">{% trans 'What is this?' %}</summary>
                                            <div style="margin-top:6px;color:#666;">{% trans 'Count of analyzed emails by the hour of day they were received (local time).' %}</div>
                                        </details>
                                        <ul class="bar-list">
                                            {% for hb in result.hour_bars %}
                                            <li class="bar-item">
                                                <div class="bar-label">{{ hb.hour }}:00</div>
                                                <div class="bar-track">
                                                    <div class="bar-fill" data-width="{{ hb.pct }}"></div>
                                                </div>
                                                <div style="width:36px; text-align:right; font-size:0.9em; color:#666;">{{ hb.count }}</div>
                                            </li>
                                            {% endfor %}
                                        </ul>
                                    </div>
                                </div>
                                <h4 style="margin-top:12px;">{% trans 'Label Distribution' %}</h4>
                                <details>
                                    <summary style="cursor:pointer;color:#555;">{% trans 'What does this show?' %}</summary>
                                    <div style="margin-top:6px;color:#666;">{% trans 'Friendly label names (e.g., Inbox, Promotions) and how many analyzed emails had each label.' %}</div>
                                </details>
                                <ul class="bar-list">
                                    {% for lb in result.label_bars %}
                                    <li class="bar-item">
                                        <div class="bar-label bar-label-wide">
                                            <span class="pill" title="{{ lb.name }}"><span class="pill-swatch" data-color="{{ lb.color }}"></span>{{ lb.name }}</span>
                                        </div>
                                        <div class="bar-track">
                                            <div class="bar-fill" data-color="{{ lb.color }}" data-width="{{ lb.pct }}"></div>
                                        </div>
                                        <div style="width:36px; text-align:right; font-size:0.9em; color:#666;">{{ lb.count }}</div>
                                    </li>
                                    {% endfor %}
                                </ul>
                                <h4>{% trans 'Insights' %}</h4>
                                <ul>
                                    {% for insight in result.insights %}
                                    <li dir="auto">{{ insight }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                    {% else %}
                        <p>{% trans 'Enter a command to get started.' %}</p>
                    {% endif %}
                </div>

                
                <div class="example-commands">
                    <h3>{% trans 'Example Commands' %}</h3>
                    <ul>
                        {% for cmd in example_commands %}
                        <li class="{% if 'label emails from' in cmd %}long-label-example {% endif %}{% if 'delete promotions older than' in cmd or 'delete all promotions older than' in cmd %}long-promo-example{% endif %}{% if 'מחק את כל קידומי המכירות ישנים מ-30 ימים' in cmd %}long-hebrew-example{% endif %}{% if 'archive emails from' in cmd or 'delete emails from' in cmd %} long-example{% endif %}"><code>{{ cmd }}</code></li>
                        {% endfor %}
                    </ul>
                </div>

                <div class="all-commands">
                    <p class="all-commands-toggle" data-show="{% trans 'Show All Commands' %}" data-hide="{% trans 'Hide All Commands' %}" onclick="toggleCommands()">{% trans 'Show All Commands' %} &#9662;</p>
                    <ul class="all-commands-list" id="all-commands-list">
                        <!-- This list can be populated from the view if we want it to be dynamic -->
                        <li><b>{% trans 'list recent emails' %}</b> - {% trans 'Shows the 10 most recent emails.' %}</li>
                        <li><b>{% trans 'list archived emails' %}</b> - {% trans 'Emails not in Inbox.' %}</li>
                        <li><b>{% trans 'list all mail' %}</b> - {% trans 'Everything in All Mail (excludes Spam/Trash).' %}</li>
                        <li><b>{% trans 'list emails from [sender/domain]' %}</b> - {% trans "e.g., 'list emails from [domain]'" %}</li>
                        <li><b>{% trans 'list emails from [timeframe]' %}</b> - {% trans "e.g., 'last week', 'yesterday', '2 days ago'" %}</li>
                        <li><b>{% trans 'list emails before [duration]' %}</b> - {% trans "e.g., '6 months', '2 weeks'" %}</li>
                        <li><b>{% trans 'list emails from [duration] ago' %}</b> - {% trans "e.g., '4 months ago'" %}</li>
                        <li><b>{% trans 'list emails older than [duration]' %}</b> - {% trans "e.g., '6 months', '1 year'" %}</li>
                        <li><b>{% trans 'list emails from [sender] from [timeframe]' %}</b> - {% trans "e.g., 'list emails from google from today', 'list emails from amazon from last month', 'list emails from google from 2 weeks ago'" %}</li>
                        <li><b>{% trans 'list emails from [sender] older than [duration]' %}</b> - {% trans "e.g., 'list emails from google older than 3 months'" %}</li>
                        <li><b>{% trans 'list verification codes' %}</b> - {% trans 'Finds login and 2FA codes.' %}</li>
                        <li><b>{% trans 'list verification codes older than [duration]' %}</b> - {% trans 'Lists codes by age window.' %}</li>
                        <li><b>{% trans 'list shipping emails' %}</b> - {% trans 'Carrier updates and delivery notices.' %}</li>
                        <li><b>{% trans 'list shipping emails older than [duration]' %}</b> - {% trans 'Carrier updates and delivery notices.' %}</li>
                        <li><b>{% trans 'list account security emails' %}</b> - {% trans 'Security alerts and sign-in notices.' %}</li>
                        <li><b>{% trans 'list account security emails older than [duration]' %}</b> - {% trans 'Older security notices.' %}</li>
                        <!-- Archive group -->
                        <li><b>{% trans 'archive emails older than [duration]' %}</b> - {% trans 'Bulk archives old emails.' %}</li>
                        <li><b>{% trans 'archive emails from [sender] older than [duration]' %}</b> - {% trans 'Archives messages from a sender with an age filter.' %}</li>
                        <li><b>{% trans 'archive emails from [sender] from [time period]' %}</b> - {% trans 'Archives messages from a sender from specific time (today, yesterday, last week, etc.).' %}</li>
                        <li><b>{% trans 'archive verification codes older than [duration]' %}</b> - {% trans 'Archives codes after a period.' %}</li>
                        <li><b>{% trans 'archive shipping emails older than [duration]' %}</b> - {% trans 'Archives old shipping updates.' %}</li>
                        <li><b>{% trans 'archive account security emails older than [duration]' %}</b> - {% trans 'Archives older security alerts.' %}</li>
                        <!-- Delete group -->
                        <li><b>{% trans 'delete emails from [sender/domain]' %}</b> - {% trans 'Moves emails to Trash.' %}</li>
                        <li><b>{% trans 'delete promotions older than [duration]' %}</b> - {% trans 'Cleans up the Promotions tab.' %}</li>
                        <li><b>{% trans 'delete verification codes older than [duration]' %}</b> - {% trans 'Cleans codes past a safe window.' %}</li>
                        <li><b>{% trans 'delete shipping emails older than [duration]' %}</b> - {% trans 'Deletes stale shipping updates.' %}</li>
                        <li><b>{% trans 'delete account security emails older than [duration]' %}</b> - {% trans 'Deletes stale security alerts.' %}</li>
                        <!-- Label group -->
                        <li><b>{% trans 'label emails from [sender] as [label]' %}</b> - {% trans 'Organizes emails with a label.' %}</li>
                        <li><b>{% trans 'list labels' %}</b> - {% trans 'Shows all your custom Gmail labels.' %}</li>
                        <li><b>{% trans 'show label "[label]"' %}</b> - {% trans 'Displays all emails with a specific label.' %}</li>
                        <!-- Stats, Search, Restore, Send -->
                        <li><b>{% trans 'show email stats' %}</b> - {% trans 'Displays a report of top senders and domains.' %}</li>
                        <li><b>{% trans 'search emails with subject [keyword]' %}</b> - {% trans 'Finds emails with a specific subject.' %}</li>
                        <li><b>{% trans 'restore emails from [sender]' %}</b> - {% trans 'Moves archived emails back to the inbox.' %}</li>
                        <li><b>{% trans 'send email' %}</b> - {% trans 'Composes and sends an email.' %}</li>
                        <!-- Deduplicated moved items removed -->
                    </ul>
                </div>

                <div class="stat-card undo-card" style="margin-top:20px;">
                    <h3>{% trans 'Undo Recent Actions' %}</h3>
                    {% if recent_actions %}
                        <ul class="stat-list">
                            {% for act in recent_actions %}
                            <li>
                                <form method="post" class="undo-form" style="display:inline-block; margin-right:10px;">
                                    {% csrf_token %}
                                    <input type="hidden" name="undo_action_id" value="{{ act.id }}">
                                    <button type="submit" class="cancel-btn undo-btn">{% trans 'Undo' %}</button>
                                </form>
                                <span>{{ act.type }} ({{ act.count }})</span>
                            </li>
                            {% endfor %}
                        </ul>
                    {% else %}
                        <p>{% trans 'No recent undoable actions.' %}</p>
                    {% endif %}
                </div>
            {% endif %}
            <details class="stat-card about-card" style="margin-top:16px;">
                <summary style="cursor:pointer;color:#555; font-weight:600;">{% trans 'About this app' %}</summary>
                <div style="margin-top:8px; color:#666;">
                    <p style="margin:0 0 6px 0; color:#666;">{% trans 'Manage your Gmail with natural-language commands: list, delete, archive, label, restore, and view stats.' %}</p>
                    <p style="margin:0; color:#666;">{% trans 'Works in English and Hebrew. No data is stored on this server; actions run via your Google account.' %}</p>
                    {% if LANGUAGE_BIDI %}
                    <p style="margin:10px 0 0 0; color:#888;">נתקלתם בבעיה או בבאג? צרו קשר בכתובת <a href="mailto:yossefmalka8@gmail.com">yossefmalka8@gmail.com</a>.</p>
                    {% else %}
                    <p style="margin:10px 0 0 0; color:#888;">{% trans 'Found an issue or a bug? Contact me at' %} <a href="mailto:yossefmalka8@gmail.com">yossefmalka8@gmail.com</a>.</p>
                    {% endif %}
                </div>
            </details>
        </main>
    </div>

    <script>
    console.log('=== SCRIPT SECTION LOADING ===');
    
            // Fix Hebrew "Your Labels" title positioning
        function forceLabelsTitlePosition() {
            const labelsTitles = document.querySelectorAll('.results .stat-card h3');
            labelsTitles.forEach((title) => {
                if (title.textContent.includes('Labels') || title.textContent.includes('תוויות')) {
                    // Position the title slightly higher
                    title.style.setProperty('position', 'relative', 'important');
                    title.style.setProperty('top', '-2px', 'important');
                    title.style.setProperty('margin-top', '-2px', 'important');
                    title.style.setProperty('padding-top', '-2px', 'important');
                }
            });
        }
    
    // Run immediately and on intervals
    setTimeout(forceLabelsTitlePosition, 100);
    setTimeout(forceLabelsTitlePosition, 500);
    setTimeout(forceLabelsTitlePosition, 1000);
    
    // Also fix it whenever results are updated
    const observer = new MutationObserver(() => {
        setTimeout(forceLabelsTitlePosition, 50);
    });
    observer.observe(document.querySelector('.results'), { childList: true, subtree: true });
    // Mobile English-only: slightly reduce font size for Example Commands (keep original text/quotes)
    function updateExampleCommandsMobileEn() {
        try {
            var isLTR = document.documentElement.getAttribute('dir') === 'ltr';
            var isSmall = window.innerWidth <= 900;
            if (!isLTR || !isSmall) return;
            var list = document.querySelector('.example-commands ul');
            if (!list) return;
            // Slightly increase from previous step, keep one-line fit
            list.style.fontSize = '13px';
            list.style.lineHeight = '1.2';
            list.querySelectorAll('li code').forEach(function(codeEl){
                codeEl.style.fontSize = '0.94em';
            });
        } catch(e) { }
    }
    document.addEventListener('DOMContentLoaded', updateExampleCommandsMobileEn);
    window.addEventListener('resize', function(){
        clearTimeout(window.__exCmdsTimer);
        window.__exCmdsTimer = setTimeout(updateExampleCommandsMobileEn, 120);
    });
    // Ensure English mobile variants show on small screens even if CSS is cached/mismatched
    function updateExampleEnglishVariants() {
        try {
            var isLTR = document.documentElement.getAttribute('dir') === 'ltr';
            var isSmall = window.innerWidth <= 900; // slightly higher threshold for phones
            var showMobile = isLTR && isSmall;
            var desktopSpans = document.querySelectorAll('.ex-en-desktop');
            var mobileSpans = document.querySelectorAll('.ex-en-mobile');
            desktopSpans.forEach(function(el){ el.style.display = showMobile ? 'none' : 'inline'; });
            mobileSpans.forEach(function(el){ el.style.display = showMobile ? 'inline' : 'none'; });
        } catch(e) {}
    }
    window.addEventListener('resize', function(){
        clearTimeout(window.__exEnSwapTimer);
        window.__exEnSwapTimer = setTimeout(updateExampleEnglishVariants, 100);
    });
    document.addEventListener('DOMContentLoaded', updateExampleEnglishVariants);
    
    function toggleCommands() {
        var list = document.getElementById("all-commands-list");
        var toggle = document.querySelector(".all-commands-toggle");
        if (list.style.display === "block") {
            list.style.display = "none";
            var showTxt = toggle ? toggle.getAttribute('data-show') || 'Show All Commands' : 'Show All Commands';
            toggle.innerHTML = showTxt + " &#9662;";
        } else {
            list.style.display = "block";
            var hideTxt = toggle ? toggle.getAttribute('data-hide') || 'Hide All Commands' : 'Hide All Commands';
            toggle.innerHTML = hideTxt + " &#9652;";
        }
    }

    function showCustomConfirmDialog() {
        var emailCount = 0;
        
        // Find the paragraph containing "Total Inbox Emails:" and extract the count
        var paragraphs = document.querySelectorAll('p');
        for (var i = 0; i < paragraphs.length; i++) {
            var p = paragraphs[i];
            if (p.textContent.includes('Total Inbox Emails:') || p.textContent.includes('סך ההודעות בתיבת הדואר הנכנס:')) {
                var text = p.textContent;
                var match = text.match(/Total Inbox Emails:\s*(\d+)|סך ההודעות בתיבת הדואר הנכנס:\s*(\d+)/);
                if (match) {
                    emailCount = parseInt(match[1] || match[2]) || 0;
                }
                break;
            }
        }
        
        // Check if we're in Hebrew mode
        var isHebrew = document.documentElement.lang === 'he';
        
        // Create custom popup
        var popup = document.createElement('div');
        popup.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        `;
        
        var content = document.createElement('div');
        content.style.cssText = `
            background: var(--secondary-color);
            color: var(--text-color);
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--primary-color);
        `;
        
        var title = document.createElement('h3');
        title.style.cssText = 'margin: 0 0 20px 0; color: var(--primary-color); font-size: 1.3em;';
        title.textContent = isHebrew ? 'אישור ניתוח מלא' : 'Confirm Full Analysis';
        
        var message = document.createElement('div');
        message.style.cssText = 'margin-bottom: 25px; line-height: 1.6;';
        
        var intro = document.createElement('p');
        intro.textContent = isHebrew ? 
            'זה יבצע ניתוח מקיף של הודעות הדואר הנכנס שלך.' :
            'This will perform a comprehensive analysis of your inbox emails.';
        
        message.appendChild(intro);
        
        if (emailCount > 1000) {
            var warning = document.createElement('p');
            warning.style.cssText = 'color: #f39c12; font-weight: bold; margin: 15px 0;';
            warning.innerHTML = isHebrew ? 
                '⚠️  <strong>חשוב:</strong> יש לך ' + emailCount + ' הודעות בתיבת הדואר הנכנס שלך.' :
                '⚠️  <strong>IMPORTANT:</strong> You have ' + emailCount + ' emails in your inbox.';
            
            var limit = document.createElement('p');
            limit.textContent = isHebrew ? 
                'כדי להבטיח זמן עיבוד סביר, הניתוח יוגבל ל-1000 ההודעות האחרונות.' :
                'To ensure reasonable processing time, the analysis will be limited to the most recent 1000 emails.';
            
            var time = document.createElement('p');
            time.style.cssText = 'margin: 15px 0; font-weight: bold;';
            time.textContent = isHebrew ? 'זמן עיבוד צפוי: 2-3 דקות' : 'Expected processing time: 2-3 minutes';
            
            var insight = document.createElement('p');
            insight.textContent = isHebrew ? 
                'זה נותן לך תובנות מקיפות תוך שמירה על זמני המתנה סבירים.' :
                'This gives you comprehensive insights while keeping wait times manageable.';
            
            message.appendChild(warning);
            message.appendChild(limit);
            message.appendChild(time);
            message.appendChild(insight);
        } else {
            var time = document.createElement('p');
            time.style.cssText = 'margin: 15px 0; font-weight: bold;';
            time.textContent = isHebrew ? 'זמן עיבוד צפוי: 1-2 דקות' : 'Expected processing time: 1-2 minutes';
            
            var all = document.createElement('p');
            all.textContent = isHebrew ? 
                'זה ינתח את כל ' + emailCount + ' ההודעות בתיבת הדואר הנכנס שלך.' :
                'This will analyze all ' + emailCount + ' emails in your inbox.';
            
            message.appendChild(time);
            message.appendChild(all);
        }
        
        var question = document.createElement('p');
        question.style.cssText = 'margin: 20px 0; font-weight: bold; font-size: 1.1em;';
        question.textContent = isHebrew ? 
            'האם אתה רוצה להמשיך עם הניתוח המלא?' :
            'Do you want to proceed with the full analysis?';
        
        message.appendChild(question);
        
        var buttons = document.createElement('div');
        buttons.style.cssText = 'display: flex; gap: 15px; justify-content: flex-end;';
        
        var cancelBtn = document.createElement('button');
        cancelBtn.style.cssText = `
            padding: 10px 20px;
            border: 1px solid var(--primary-color);
            background: transparent;
            color: var(--primary-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
        `;
        cancelBtn.textContent = isHebrew ? 'ביטול' : 'Cancel';
        cancelBtn.onclick = function() {
            document.body.removeChild(popup);
        };
        
        var confirmBtn = document.createElement('button');
        confirmBtn.style.cssText = `
            padding: 10px 20px;
            border: none;
            background: var(--primary-color);
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
        `;
        confirmBtn.textContent = isHebrew ? 'המשך' : 'Continue';
        confirmBtn.onclick = function() {
            document.body.removeChild(popup);
            
            // Generate command ID for progress tracking
            const commandId = 'cmd_' + Date.now() + '_' + Math.random().toString(36).substr(2, 10);
            
            // Show stats loading screen for full analysis (with fun facts)
            showStatsLoadingScreen();
            
            // Connect to progress stream for real-time updates
            connectToProgressStream(commandId, 'stats');
            
            // Create and submit the form
            const form = document.createElement('form');
            form.method = 'POST';
            form.action = '';
            
            const csrfToken = document.querySelector('input[name="csrfmiddlewaretoken"]');
            if (csrfToken) {
                const csrfInput = document.createElement('input');
                csrfInput.type = 'hidden';
                csrfInput.name = 'csrfmiddlewaretoken';
                csrfInput.value = csrfToken.value;
                form.appendChild(csrfInput);
            }
            
            const statsFullInput = document.createElement('input');
            statsFullInput.type = 'hidden';
            statsFullInput.name = 'stats_full';
            statsFullInput.value = '1';
            form.appendChild(statsFullInput);
            
            // Add command ID for progress tracking
            const commandIdInput = document.createElement('input');
            commandIdInput.type = 'hidden';
            commandIdInput.name = 'command_id';
            commandIdInput.value = commandId;
            form.appendChild(commandIdInput);
            
            document.body.appendChild(form);
            form.submit();
        };
        
        buttons.appendChild(cancelBtn);
        buttons.appendChild(confirmBtn);
        
        content.appendChild(title);
        content.appendChild(message);
        content.appendChild(buttons);
        popup.appendChild(content);
        
        document.body.appendChild(popup);
    }

    document.addEventListener('DOMContentLoaded', function() {
        // Theme init
        try {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
            }
            const toggleBtn = document.getElementById('theme-toggle');
            const label = document.getElementById('theme-label');
            function applyThemeUI() {
                const isDark = document.body.getAttribute('data-theme') === 'dark';
                if (label) label.textContent = isDark ? (document.documentElement.dir === 'rtl' ? 'כהה' : 'Dark') : (document.documentElement.dir === 'rtl' ? 'בהיר' : 'Light');
                
                // Fix Hebrew switch positioning
                const isHebrew = document.documentElement.lang === 'he';
                if (isHebrew) {
                    const switchThumb = document.querySelector('.switch-thumb');
                    const switchTrack = document.querySelector('.switch-track');
                    if (switchThumb && switchTrack) {
                        if (isDark) {
                            // Dark mode: thumb on right (showing moon)
                            switchThumb.style.left = 'calc(100% - 26px)';
                            switchTrack.style.setProperty('--thumb-left', 'calc(100% - 26px)');
                        } else {
                            // Light mode: thumb on left (showing sun)
                            switchThumb.style.left = '4px';
                            switchTrack.style.setProperty('--thumb-left', '4px');
                        }
                    }
                }
            }
            applyThemeUI();
            if (toggleBtn) {
                toggleBtn.addEventListener('click', function(){
                    const isDark = document.body.getAttribute('data-theme') === 'dark';
                    if (isDark) {
                        document.body.removeAttribute('data-theme');
                        localStorage.setItem('theme', 'light');
                    } else {
                        document.body.setAttribute('data-theme', 'dark');
                        localStorage.setItem('theme', 'dark');
                    }
                    applyThemeUI();
                });
            }
        } catch(e) {}
        
        // Listen for language changes to fix Hebrew switch
        const languageSelect = document.getElementById('language-select');
        if (languageSelect) {
            languageSelect.addEventListener('change', function() {
                // Wait a bit for the page to reload with new language
                setTimeout(() => {
                    if (document.documentElement.lang === 'he') {
                        applyThemeUI();
                    }
                }, 100);
            });
        }
        
        const commandInput = document.getElementById('command-input');
        const form = document.getElementById('command-form');
        const processBtn = document.getElementById('command-submit');
        const overlay = document.getElementById('loading-overlay');
        const snackbar = document.getElementById('snackbar');
        const i18n = document.body ? document.body.dataset : {};
        let suggestionsContainer = null;
        let isSubmitting = false;
        // Set up event delegation for Full Analysis button (works even if button doesn't exist yet)
        document.addEventListener('click', function(e) {
            if (e.target && e.target.id === 'full-stats-btn') {
                console.log('Full Analysis button clicked via event delegation!');
                e.preventDefault();
                showCustomConfirmDialog();
            }
        });
        console.log('Event delegation set up for Full Analysis button');
        
        // Apply dynamic bar styles after DOM is ready
        try {
            document.querySelectorAll('.bar-fill').forEach(function(el){
                const pct = el.getAttribute('data-width');
                if (pct !== null) {
                    el.style.width = pct + '%';
                }
                const color = el.getAttribute('data-color');
                if (color) {
                    el.style.background = color;
                }
            });
            document.querySelectorAll('.pill-swatch').forEach(function(el){
                const color = el.getAttribute('data-color');
                if (color) el.style.background = color;
            });
        } catch (e) {}


        function showSnackbar(message, type, options) {
            if (!snackbar) return;
            snackbar.innerHTML = '';
            const msgSpan = document.createElement('span');
            msgSpan.textContent = message || '';
            snackbar.appendChild(msgSpan);
            if (options && options.details) {
                const anchor = document.createElement('a');
                anchor.href = '#';
                anchor.textContent = i18n.i18nViewDetails || 'View details';
                anchor.addEventListener('click', function(e) {
                    e.preventDefault();
                    const resultsBox = document.querySelector('.results');
                    if (resultsBox) {
                        resultsBox.scrollIntoView({behavior: 'smooth', block: 'start'});
                        resultsBox.classList.remove('highlight');
                        // trigger reflow to restart animation if applied recently
                        void resultsBox.offsetWidth;
                        resultsBox.classList.add('highlight');
                    }
                });
                snackbar.appendChild(anchor);
            }
            snackbar.className = 'snackbar show';
            if (type === 'success') snackbar.classList.add('success');
            else if (type === 'error') snackbar.classList.add('error');
            else snackbar.classList.add('info');
            setTimeout(() => { snackbar.className = 'snackbar'; }, 5000);
        }

        // Show snackbar if server rendered a message
        try {
            const initialStatus = "{{ result.status|default_if_none:'' }}".trim();
            const initialMsg = "{{ result.message|default_if_none:''|escapejs }}".trim();
            if (initialStatus && initialMsg) {
                showSnackbar(initialMsg, initialStatus, {details: true});
            }
        } catch (e) {}

        let commands = (() => {
            console.log('Raw autocomplete_commands_json:', '{{ autocomplete_commands_json|escapejs }}');
            try {
                const parsed = JSON.parse('{{ autocomplete_commands_json|escapejs }}');
                console.log('Parsed commands:', parsed);
                if (Array.isArray(parsed) && parsed.length) return parsed;
            } catch(e) {
                console.error('Autocomplete JSON parse failed', e);
            }
            console.log('Using fallback commands');
            return [
                'list recent emails',
                'list emails from [domain.com]',
                'list emails from last week',
                'list emails from last month',
                'list emails from yesterday',
                'list emails from [duration] ago',
                'list emails older than [duration]',
                'search emails with subject "[keyword]"',
                'show email stats',
                'delete emails from [domain.com]',
                'delete all promotions older than [duration]',
                'delete emails from [sender] older than [duration]',
                'delete all emails older than [duration]',
                'archive emails older than [duration]',
                'archive emails from [sender] older than [duration]',
                'archive emails from [sender] from [time period]',
                '• label emails from [sender] as "[label]"',
                'list labels',
                'show label "[label]"',
                'restore emails from [sender]',
                'send email'
            ];
        })();

        // Remove generic timeframe placeholder list-commands from autocomplete
        // Keep specific phrases (today/yesterday/last week/etc.) and sender+timeframe templates
        try {
            const timeframePlaceholderRe = /\[(time\s*frame|time\s*period)\]/i;
            commands = (Array.isArray(commands) ? commands : []).filter(function(c){
                const lc = (c || '').toLowerCase();
                if (!/^list\b/.test(lc)) return true;
                if (timeframePlaceholderRe.test(lc) && !/\[sender\]/i.test(lc)) return false;
                return true;
            });
        } catch (e) {}

        // Fuzzy helpers
        function levenshtein(a, b) {
            a = a || ''; b = b || '';
            const m = a.length, n = b.length;
            if (m === 0) return n; if (n === 0) return m;
            const dp = new Array(n + 1);
            for (let j = 0; j <= n; j++) dp[j] = j;
            for (let i = 1; i <= m; i++) {
                let prev = dp[0]; dp[0] = i;
                for (let j = 1; j <= n; j++) {
                    const temp = dp[j];
                    if (a.charCodeAt(i - 1) === b.charCodeAt(j - 1)) {
                        dp[j] = prev;
                    } else {
                        dp[j] = Math.min(prev + 1, dp[j] + 1, dp[j - 1] + 1);
                    }
                    prev = temp;
                }
            }
            return dp[n];
        }
        function similarity(q, s) {
            if (!q || !s) return 0;
            const a = q.toLowerCase().trim();
            const b = s.toLowerCase().trim();
            const maxLen = Math.max(a.length, b.length) || 1;
            const dist = levenshtein(a, b);
            return 1 - (dist / maxLen);
        }
        function getSuggestions(input, maxShow) {
            const q = (input || '').toLowerCase().trim();
            const scored = [];
            const includeMatches = [];

            // Detect fixed timeframe cues so we can suppress '[duration] ago' templates
            const hasFixedTimeCue = (() => {
                try {
                    // Direct full-word cues anywhere
                    if (/\b(today|yesterday)\b/i.test(q)) return true;
                    if (/\bfrom\s+(last|this)\b/i.test(q)) return true;
                    // Extract the token immediately following the LAST 'from '
                    let token = '';
                    let m = q.match(/\bfrom\s+([^\s]+)/ig);
                    if (m && m.length) {
                        const lastFrom = m[m.length - 1];
                        const mTok = lastFrom.match(/\bfrom\s+([a-z]+)/i);
                        if (mTok && mTok[1]) token = mTok[1];
                    } else {
                        // Base pattern: 'list emails from <token>'
                        const mBase = q.match(/\blist\s+emails\s+from\s+([a-z]+)/i);
                        if (mBase && mBase[1]) token = mBase[1];
                    }
                    if (token) {
                        const timeWords = ['today','yesterday','last','this'];
                        const isTimePrefix = timeWords.some(w => w.startsWith(token));
                        if (isTimePrefix) return true;
                    }
                    return false;
                } catch (e) { return false; }
            })();

            // Helper to escape regex special chars
            function escapeRegex(s) {
                return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];
                const lc = cmd.toLowerCase();

                // 1) Prefix match only (avoid mid-string bolding of unrelated commands)
                if (q.length > 0 && lc.startsWith(q)) {
                    const pos = 0;
                    let score = 1.0 - (lc.length - q.length) * 0.001;
                    if (cmd.includes('recent') || cmd.includes('send') || cmd.includes('delete') ||
                        cmd.includes('archive') || cmd.includes('stats') || cmd.includes('list')) {
                        score += 0.2;
                    }
                    if (cmd === 'list recent emails' || cmd === 'send email' ||
                        cmd === 'show email stats' || cmd === 'delete all promotions') {
                        score += 0.3;
                    }
                    score += 0.1; // starts-with bonus
                    includeMatches.push({ cmd, score, type: 'include', pos });
                    continue; // we already included this via direct match
                }

                // 2) Placeholder-aware prefix match so suggestions persist after filling slots
                // Detect templates with placeholders like [sender], [domain.com], [duration], [time period] (including Hebrew labels)
                if (/\[[^\]]+\]/.test(lc)) {
                    const parts = lc.split(/\[[^\]]+\]/); // fixed text chunks around placeholders
                    const fixedPrefix = parts[0] || '';
                    if (fixedPrefix && q.startsWith(fixedPrefix)) {
                        // Base score for prefix-only match (keep; will be outranked by deeper matches)
                        const fixedSegmentsCount = parts.filter(p => p.length > 0).length;
                        let score = 0.50 + Math.min(0.05, fixedPrefix.length / Math.max(1, lc.length)) + fixedSegmentsCount * 0.005;
                        // Early mismatch guard: if user typed a different next fixed word (e.g., 'older' vs template 'before'), drop it
                        const nextFixed = parts[1] || '';
                        const nextWord = (nextFixed.trim().match(/^[a-z\u0590-\u05FF]+/i) || [''])[0].toLowerCase();
                        const typedAfter = q.slice(fixedPrefix.length).trimLeft();
                        const typedWord = (typedAfter.match(/^[a-z0-9\u0590-\u05FF]+/i) || [''])[0].toLowerCase();
                        const earlyMismatch = typedWord.length >= 2 && nextWord && !nextWord.startsWith(typedWord);
                        if (!earlyMismatch) {
                            scored.push({ cmd, score, type: 'placeholder', prefixLen: fixedPrefix.length });
                        }
                    }

                    // Also allow ordered-match across multiple fixed parts, anchored at start
                    // Build a loose regex that treats placeholders as wildcards, but requires '^'
                    try {
                        const pattern = '^' + parts.map(p => escapeRegex(p)).join('.*');
                        const re = new RegExp(pattern);
                        if (re.test(q)) {
                            // Prefer more specific templates (more/larger fixed segments)
                            const fixedSegmentsCount = parts.filter(p => p.length > 0).length;
                            const fixedChars = parts.reduce((s, p) => s + p.length, 0);
                            // Heuristic boost if the user's input contains words hinting at specific templates
                            const inputHasDuration = /(\d+\s*(day|week|month|year|יום|שבוע|חודש|שנה)s?\b|ago|לפני)/.test(q);
                            const inputHasFromTime = /\bfrom\b|\bמה(יום|שבוע|חודש|שנה)/.test(q);
                            let score = 0.82 + Math.min(0.12, fixedChars / Math.max(1, lc.length)) + fixedSegmentsCount * 0.05;
                            if (inputHasDuration && lc.includes('[duration]')) score += 0.12;
                            if (inputHasFromTime && lc.includes('[time')) score += 0.06;
                            // Early mismatch guard on the next fixed word
                            const fixedPrefix = parts[0] || '';
                            const nextFixed = parts[1] || '';
                            const nextWord = (nextFixed.trim().match(/^[a-z\u0590-\u05FF]+/i) || [''])[0].toLowerCase();
                            const typedAfter = q.slice(fixedPrefix.length).trimLeft();
                            const typedWord = (typedAfter.match(/^[a-z0-9\u0590-\u05FF]+/i) || [''])[0].toLowerCase();
                            const earlyMismatch = typedWord.length >= 2 && nextWord && !nextWord.startsWith(typedWord);
                            if (!earlyMismatch) {
                                scored.push({ cmd, score, type: 'placeholder', prefixLen: (parts[0] || '').length });
                            }
                            continue;
                        }
                    } catch (e) {
                        // ignore regex build errors and fall through
                    }
                }
            }

            // Alignment-based ranking (sender-first): only engage after a clear sender cue
            // (e.g., typing "from" in EN or "מ-"/" מ" in HE). Prevents sender templates
            // from outranking unrelated commands like "list recent emails".
            function alignedMatchLength(cmd, q) {
                const hasSender = /\[(sender|domain\.com|שולח|דומיין)\]/i.test(cmd);
                if (!hasSender || !q) return 0;
                const partialFromCue = /\blist\s+emails\s+f(?:r|ro)?$/i.test(q);
                const hasSenderCue = /\bfrom\b|\bמ(?:-|\s)/i.test(q) || partialFromCue;
                if (!hasSenderCue) return 0;
                // Suppress sender ranking only when the token after "from" is a real timeframe prefix
                let hasTimeCue = false;
                try {
                    const m = q.match(/\bfrom\s+([a-z0-9\.\-]+)/i);
                    if (m && m[1]) {
                        const tok = m[1];
                        // Domain heuristic: if token looks like a domain or ends with .com, prefer sender
                        if (/\.|\.com$/i.test(tok)) {
                            hasTimeCue = false;
                        } else 
                        if (/^\d/.test(tok)) {
                            hasTimeCue = true; // numeric start (e.g., 5 days ...)
                        } else {
                            const timePrefixes = ['today','yesterday','last','this'];
                            hasTimeCue = timePrefixes.some(w => w.startsWith(tok));
                        }
                    }
                } catch (e) { hasTimeCue = false; }
                if (hasTimeCue) return 0;
                return computeSenderBoldLength(cmd, q);
            }

            const aligned = commands
                .map(c => ({ cmd: c, score: alignedMatchLength(c, q) || 0 }))
                .filter(x => x.score > 0);

            // Merge: take the best aligned match to the front, then others by previous scoring
            aligned.sort((a, b) => b.score - a.score);
            const bestAligned = aligned.length ? aligned[0].cmd : null;
            const merged = [];
            const seen = new Set();
            if (bestAligned) { merged.push({ cmd: bestAligned, score: 10, type: 'aligned' }); seen.add(bestAligned); }

            // Prioritize starts-with and exact includes first, then others
            includeMatches.sort((a, b) => {
                const aStart = commands.indexOf(a.cmd) >= 0 && a.cmd.toLowerCase().startsWith(q);
                const bStart = commands.indexOf(b.cmd) >= 0 && b.cmd.toLowerCase().startsWith(q);
                if (aStart && !bStart) return -1;
                if (!aStart && bStart) return 1;
                return b.score - a.score;
            });
            for (let k = 0; k < includeMatches.length; k++) if (!seen.has(includeMatches[k].cmd)) { merged.push(includeMatches[k]); seen.add(includeMatches[k].cmd); }

            // PRIORITY: If user typed a numeric duration after 'from', surface 'list emails from [duration] ago'
            try {
                const numDurCue = /\blist\s+emails\s+from\s+\d+/i.test(q);
                if (numDurCue) {
                    const target = commands.find(c => /\blist\s+emails\s+from\s+\[duration\]\s+ago\b/i.test(c));
                    if (target && !seen.has(target)) {
                        merged.unshift({ cmd: target, score: 9.8, type: 'duration_time' });
                        seen.add(target);
                    }
                }
            } catch (e) {}

            // PRIORITY: If pattern is 'list emails from <sender> from <number>', prefer sender+duration-ago template
            try {
                const mSenderNum = q.match(/\blist\s+emails\s+from\s+([^\s].*?)\s+from\s+\d+/i);
                if (mSenderNum) {
                    const senderDurAgo = commands.find(c => /\blist\s+emails\s+from\s+\[sender\][^\n]*\s+from\s+\[duration\]\s+ago\b/i.test(c));
                    if (senderDurAgo && !seen.has(senderDurAgo)) {
                        merged.unshift({ cmd: senderDurAgo, score: 9.85, type: 'sender_duration_num' });
                        seen.add(senderDurAgo);
                    }
                }
            } catch (e) {}

            // Add placeholder-aware matches (kept separate earlier as 'scored')
            // Boost 'last'/'this' variants when the user starts typing them
            const wantLast = /\bfrom\s+[^\s]+\s+from\s+l/i.test(q) || /\blast\b/i.test(q);
            const wantThis = /\bfrom\s+[^\s]+\s+from\s+t/i.test(q) || /\bthis\b/i.test(q);
            scored.sort((a, b) => {
                const la = a.cmd.toLowerCase();
                const lb = b.cmd.toLowerCase();
                let sa = a.score, sb = b.score;
                if (wantLast) { if (la.includes(' last ')) sa += 0.8; if (lb.includes(' last ')) sb += 0.8; }
                if (wantThis) { if (la.includes(' this ')) sa += 0.8; if (lb.includes(' this ')) sb += 0.8; }
                return sb - sa;
            });
            for (let k = 0; k < scored.length; k++) if (!seen.has(scored[k].cmd)) { merged.push(scored[k]); seen.add(scored[k].cmd); }

            // PRIORITY GROUP: When typing "list emails from <sender> from l|t...",
            // float sender+timeframe templates (with both [sender] and ' last '/' this ') to the top block
            try {
                const senderTimeCue = q.match(/\blist\s+emails\s+from\s+([^\s]+)\s+from\s+([lt])/i);
                if (senderTimeCue) {
                    const letter = senderTimeCue[2].toLowerCase();
                    const preferLast = letter === 'l';
                    const preferThis = letter === 't';
                    const prioritized = [];
                    for (let i = 0; i < commands.length; i++) {
                        const c = commands[i];
                        const lcC = c.toLowerCase();
                        const hasSender = /\[sender\]|\[domain\.com\]|\[שולח\]|\[דומיין\]/i.test(c);
                        const hasLast = lcC.includes(' from last ');
                        const hasThis = lcC.includes(' from this ');
                        if (!hasSender) continue;
                        if ((preferLast && hasLast) || (preferThis && hasThis)) {
                            prioritized.push({ cmd: c, score: 9.5, type: 'sender_time' });
                        }
                    }
                    // Insert prioritized items right after any aligned best match
                    prioritized.forEach(item => { if (!seen.has(item.cmd)) { merged.splice(merged.length > 0 ? 1 : 0, 0, item); seen.add(item.cmd); } });
                }
            } catch (e) {}

            // ENSURE VISIBILITY (guarded): keep 'sender from [duration] ago' only when not on fixed timeframe flow
            if (!hasFixedTimeCue) {
                try {
                    const baseSenderCue = /\blist\s+emails\s+from\b/i.test(q);
                    if (baseSenderCue) {
                        const senderDurAgo = commands.find(c => /\blist\s+emails\s+from\s+\[sender\][^\n]*\s+from\s+\[duration\]\s+ago\b/i.test(c));
                        if (senderDurAgo && !seen.has(senderDurAgo)) {
                            // place after any aligned item but before general includes
                            merged.splice(merged.length > 0 ? 1 : 0, 0, { cmd: senderDurAgo, score: 8.9, type: 'sender_duration_seed' });
                            seen.add(senderDurAgo);
                        }
                    }
                } catch (e) {}
            }
            // Fuzzy fallback independent of direct includes, so templates with placeholders appear
            const fuzzyList = [];
            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];
                if (seen.has(cmd)) continue;
                const lc = cmd.toLowerCase();
                const sim = similarity(q, lc);
                if (sim >= 0.42 || q.length >= 3) {
                    fuzzyList.push({ cmd, score: sim, type: 'fuzzy' });
                }
            }
            fuzzyList.sort((a, b) => b.score - a.score);
            for (let k = 0; k < fuzzyList.length; k++) if (!seen.has(fuzzyList[k].cmd)) { merged.push(fuzzyList[k]); seen.add(fuzzyList[k].cmd); }

            // If typing fixed timeframe (today/this/last/yesterday), demote or drop '[duration] ago' variants
            if (hasFixedTimeCue) {
                const durAgoRe = /\bfrom\s+\[duration\]\s+ago\b/i;
                // First, lower their scores so fixed-time suggestions stay above
                for (let i = 0; i < merged.length; i++) {
                    if (merged[i] && merged[i].cmd && durAgoRe.test(merged[i].cmd)) {
                        // reduce effective score substantially
                        merged[i].score = (merged[i].score || 0) - 5;
                    }
                }
                // Move duration-ago items to the end while preserving order otherwise
                merged.sort((a, b) => {
                    const aDur = a && a.cmd && durAgoRe.test(a.cmd);
                    const bDur = b && b.cmd && durAgoRe.test(b.cmd);
                    if (aDur && !bDur) return 1;
                    if (!aDur && bDur) return -1;
                    // keep previous ordering between same class
                    return 0;
                });
            }

            // Unique and truncate (simple, proven ordering)
            const unique = [];
            const seen2 = new Set();
            for (let i = 0; i < merged.length && unique.length < maxShow; i++) {
                const c = merged[i].cmd;
                if (!seen2.has(c)) { seen2.add(c); unique.push(merged[i]); }
            }
            return unique;
        }

        // Compute how much of a placeholder template should be bolded based on user input
        // Example: cmd = 'list emails from [sender] older than [duration]'
        // If input = 'list emails from google older', bold covers up to 'list emails from [sender] older'
        function computePlaceholderBoldLength(cmd, input) {
            try {
                const q = (input || '').toLowerCase();
                const fixedSegments = cmd.split(/\[[^\]]+\]/); // fixed pieces
                const placeholderTokens = cmd.match(/\[[^\]]+\]/g) || []; // tokens like [sender]
                let pos = 0;     // pointer in user input
                let coverage = 0; // number of chars in template to bold

                for (let i = 0; i < fixedSegments.length; i++) {
                    const fixed = fixedSegments[i] || '';
                    const fixedLc = fixed.toLowerCase();

                    // Match current fixed segment as far as typed
                    if (fixedLc.length) {
                        let j = 0;
                        while (j < fixedLc.length && pos + j < q.length && q.charAt(pos + j) === fixedLc.charAt(j)) {
                            j++;
                        }
                        coverage += j;
                        pos += j;
                        if (j < fixedLc.length) {
                            // user stopped mid-fixed
                            return Math.min(coverage, cmd.length);
                        }
                    }

                    // Handle placeholder following this fixed (except after the last fixed piece)
                    if (i < placeholderTokens.length) {
                        const token = placeholderTokens[i] || '';
                        const nextFixedLc = (fixedSegments[i + 1] || '').toLowerCase();
                        if (!nextFixedLc) {
                            // trailing placeholder; user typed anything beyond pos -> count placeholder
                            if (pos < q.length) coverage += token.length;
                        } else {
                            // Look for next fixed segment in the remaining input
                            const idxNext = q.indexOf(nextFixedLc, pos);
                            // Compute how many chars of next fixed the user has typed (prefix match)
                            const remaining = q.slice(pos);
                            let prefixMatch = 0;
                            while (prefixMatch < nextFixedLc.length && prefixMatch < remaining.length && remaining.charAt(prefixMatch) === nextFixedLc.charAt(prefixMatch)) {
                                prefixMatch++;
                            }

                            if (idxNext > pos) {
                                // There is placeholder content before the next fixed
                                coverage += token.length;
                                // Add per-letter bold for the beginning of the next fixed that is already typed
                                coverage += prefixMatch;
                                return Math.min(coverage, cmd.length);
                            } else if (idxNext === pos) {
                                // No placeholder content yet; still allow per-letter bold on the next fixed as user types it
                                coverage += prefixMatch;
                                if (prefixMatch < nextFixedLc.length) {
                                    return Math.min(coverage, cmd.length);
                                }
                                // Full next fixed typed; continue to next loop iteration to process more
                            } else if (idxNext === -1) {
                                // Next fixed not fully present. If the user typed anything, consider placeholder in progress
                                if (pos < q.length) {
                                    coverage += token.length;
                                    coverage += prefixMatch; // and any partial of next fixed typed
                                    return Math.min(coverage, cmd.length);
                                }
                            }
                        }
                    }
                }

                return Math.min(coverage, cmd.length);
            } catch (e) {
                return 0;
            }
        }

        // Sender-focused bolding: while user types a sender/domain between fixed parts,
        // bold the entire [sender]-like token as soon as they type any character into it.
        function computeSenderBoldLength(cmd, input) {
            try {
                const tokenMatch = cmd.match(/\[(sender|domain\.com|שולח|דומיין)\]/i);
                if (!tokenMatch) return -1;
                const tokenStart = tokenMatch.index || 0;
                const token = tokenMatch[0];
                const parts = cmd.split(/\[[^\]]+\]/);
                // Find index of the sender placeholder among placeholders
                const placeholderList = (cmd.toLowerCase().match(/\[[^\]]+\]/g) || []);
                const senderIdx = placeholderList.findIndex(p => /\[(sender|domain\.com|שולח|דומיין)\]/i.test(p));
                const before = parts[senderIdx] || '';
                const after = parts[senderIdx + 1] || '';

                const q = (input || '').toLowerCase();
                const beforeLc = before.toLowerCase();
                const afterLc = after.toLowerCase();

                // Match the fixed prefix per letter
                let matched = 0;
                while (matched < beforeLc.length && matched < q.length && q.charAt(matched) === beforeLc.charAt(matched)) matched++;
                if (matched < beforeLc.length) return matched; // still typing prefix

                // Inside or past the sender slot -> bold through the token
                let coverage = before.length + token.length;

                // Extend bold into the next fixed word per letter, regardless of how long the sender is
                if (afterLc && q.length > matched) {
                    // Typed content inside placeholder
                    const typedInside = q.slice(matched);
                    // We want the longest prefix of 'afterLc' that is a SUFFIX of typedInside
                    // so bold progresses smoothly into the next fixed word as the user types it
                    let best = 0;
                    const maxPref = Math.min(afterLc.length, typedInside.length);
                    for (let k = maxPref; k >= 1; k--) {
                        if (typedInside.endsWith(afterLc.substring(0, k))) { best = k; break; }
                    }
                    coverage += best;
                }
                return Math.min(coverage, cmd.length);
            } catch (e) {
                return -1;
            }
        }

        function escapeHtml(s) {
            if (!s) return '';
            return s
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        }

        function longestCommonPrefixLen(a, b) {
            const m = Math.min(a.length, b.length);
            let i = 0;
            while (i < m && a.charAt(i) === b.charAt(i)) i++;
            return i;
        }

        // Materialize the [sender] token with what the user typed and compute bold
        function renderSenderMaterialized(div, cmd, input) {
            const tokenRegex = /\[(sender(?:\/domain)?|domain(?:\.com)?|שולח(?:\/דומיין)?|דומיין)\]/i;
            const lcCmd = cmd.toLowerCase();
            const tokenM = lcCmd.match(tokenRegex);
            if (!tokenM) return false;

            const tokenIdx = tokenM.index || 0;
            const tokenText = cmd.substr(tokenIdx, tokenM[0].length);
            const before = cmd.substring(0, tokenIdx);
            const afterStart = tokenIdx + tokenText.length;
            const nextPlaceholderIdx = cmd.indexOf('[', afterStart);
            const afterFixed = nextPlaceholderIdx === -1 ? cmd.substring(afterStart) : cmd.substring(afterStart, nextPlaceholderIdx);
            // If there is a next placeholder (e.g., [duration]), capture it and the fixed text after it (e.g., ' ago')
            let nextTokenText = '';
            let afterNextFixed = '';
            if (nextPlaceholderIdx !== -1) {
                const closeIdx = cmd.indexOf(']', nextPlaceholderIdx);
                if (closeIdx !== -1) {
                    nextTokenText = cmd.substring(nextPlaceholderIdx, closeIdx + 1);
                    const afterNextStart = closeIdx + 1;
                    const next2Idx = cmd.indexOf('[', afterNextStart);
                    afterNextFixed = next2Idx === -1 ? cmd.substring(afterNextStart) : cmd.substring(afterNextStart, next2Idx);
                }
            }

            const beforeLc = before.toLowerCase();
            const q = (input || '').toLowerCase();

            // If user hasn't matched the fixed prefix fully yet, bold ONLY within the fixed prefix per letter
            const startsWithBefore = q.startsWith(beforeLc);
            if (!startsWithBefore) {
                const cutoff = Math.min(q.length, before.length);
                const bold = escapeHtml(cmd.substring(0, cutoff));
                const rest = escapeHtml(cmd.substring(cutoff));
                div.innerHTML = `<strong>${bold}</strong>${rest}`;
                return true;
            }

            const typedAfterPrefix = q.length > beforeLc.length ? q.slice(beforeLc.length) : '';
            // Determine how much of the next fixed segment (e.g., ' from ') the user already typed (k)
            const afterFixedLc = (afterFixed || '').toLowerCase();
            let k = 0;
            if (afterFixedLc && typedAfterPrefix) {
                if (typedAfterPrefix.indexOf(afterFixedLc) !== -1) {
                    k = afterFixedLc.length;
                } else {
                    const maxPref = Math.min(afterFixedLc.length, typedAfterPrefix.length);
                    for (let i2 = maxPref; i2 >= 1; i2--) {
                        if (typedAfterPrefix.endsWith(afterFixedLc.substring(0, i2))) { k = i2; break; }
                    }
                }
            }

            // Special handling: if next token is [duration], bold through it as soon as any characters are typed after ' from '
            if (nextTokenText) {
                const idxFixed = typedAfterPrefix.indexOf(afterFixedLc);
                if (idxFixed !== -1) {
                    const afterAfterFixedTyped = typedAfterPrefix.slice(idxFixed + afterFixedLc.length);
                    if (afterAfterFixedTyped.length > 0) {
                        // Bold up to and including [sender], ' from ', and the [duration] token
                        const afterNextFixedLc = (afterNextFixed || '').toLowerCase();
                        let k2 = 0;
                        if (afterNextFixedLc) {
                            const max2 = Math.min(afterNextFixedLc.length, afterAfterFixedTyped.length);
                            for (let j = max2; j >= 1; j--) {
                                if (afterAfterFixedTyped.endsWith(afterNextFixedLc.substring(0, j))) { k2 = j; break; }
                            }
                        }
                        const strongEnd = before.length + tokenText.length + afterFixed.length + nextTokenText.length + k2;
                        const bold = escapeHtml(cmd.substring(0, strongEnd));
                        const rest = escapeHtml(cmd.substring(strongEnd));
                        div.innerHTML = `<strong>${bold}</strong>${rest}`;
                        return true;
                    }
                }
            }
            const typedInsidePlaceholderLen = Math.max(0, typedAfterPrefix.length - k);
            const materialized = (before + typedAfterPrefix + afterFixed).toLowerCase();
            const cutoffMat = longestCommonPrefixLen(materialized, q);

            // Map materialized cutoff back to template cutoff
            let cutoffTpl;
            if (cutoffMat <= before.length) {
                cutoffTpl = cutoffMat;
            } else if (cutoffMat <= before.length + typedInsidePlaceholderLen) {
                cutoffTpl = before.length + tokenText.length; // bold full [sender]
            } else {
                const extra = cutoffMat - (before.length + typedInsidePlaceholderLen);
                cutoffTpl = before.length + tokenText.length + extra;
            }
            cutoffTpl = Math.max(0, Math.min(cutoffTpl, cmd.length));

            const bold = escapeHtml(cmd.substring(0, cutoffTpl));
            const rest = escapeHtml(cmd.substring(cutoffTpl));
            div.innerHTML = `<strong>${bold}</strong>${rest}`;
            return true;
        }

        // Materialize [duration]/[timeframe]/[time period] tokens and compute bold continuation
        function renderDurationMaterialized(div, cmd, input) {
            const tokenRegex = /\[(duration|time\s*frame|time\s*period|משך(?:\s*זמן)?|טווח(?:\s*זמן)?|פרק(?:\s*זמן)?)\]/i;
            const lcCmd = cmd.toLowerCase();
            const tokenM = lcCmd.match(tokenRegex);
            if (!tokenM) return false;

            const tokenIdx = tokenM.index || 0;
            const tokenEnd = lcCmd.indexOf(']', tokenIdx) + 1;
            const tokenText = cmd.substring(tokenIdx, tokenEnd);

            // Fixed text immediately before the duration-like token
            let lastClose = cmd.lastIndexOf(']', tokenIdx - 1);
            if (lastClose < 0) lastClose = 0;
            const beforeFixed = lastClose > 0 ? cmd.substring(lastClose + 1, tokenIdx) : (cmd.substring(0, tokenIdx).split(/\[[^\]]+\]/).pop() || '');
            const beforeFixedLc = beforeFixed.toLowerCase();

            const q = (input || '').toLowerCase();
            const anchorPos = beforeFixedLc ? q.lastIndexOf(beforeFixedLc) : -1;
            if (beforeFixedLc && anchorPos === -1) return false;

            // Characters typed after the anchor (fixed text before the token)
            const afterAnchor = beforeFixedLc ? q.slice(anchorPos + beforeFixedLc.length) : q;

            // Fixed text after the duration-like token up to the next placeholder (if any)
            const afterStart = tokenEnd;
            const nextPlaceholderIdx = cmd.indexOf('[', afterStart);
            const afterFixed = nextPlaceholderIdx === -1 ? cmd.substring(afterStart) : cmd.substring(afterStart, nextPlaceholderIdx);
            const afterFixedLc = (afterFixed || '').toLowerCase();

            // How much of the following fixed text is already typed at the end
            let k = 0;
            if (afterFixedLc && afterAnchor) {
                const maxPref = Math.min(afterFixedLc.length, afterAnchor.length);
                for (let i2 = maxPref; i2 >= 1; i2--) {
                    if (afterAnchor.endsWith(afterFixedLc.substring(0, i2))) { k = i2; break; }
                }
            }

            const strongEnd = afterStart + k; // include token fully and k chars of next fixed
            const bold = escapeHtml(cmd.substring(0, tokenIdx + tokenText.length + (k > 0 ? k : 0)));
            const rest = escapeHtml(cmd.substring(tokenIdx + tokenText.length + (k > 0 ? k : 0)));
            div.innerHTML = `<strong>${bold}</strong>${rest}`;
            return true;
        }

        // Compute-only variants to get the same visual bold cutoff used by renderers
        function computeMaterializedSenderCutoff(cmd, input) {
            try {
                const tokenRegex = /\[(sender(?:\/domain)?|domain(?:\.com)?|שולח(?:\/דומיין)?|דומיין)\]/i;
                const lcCmd = cmd.toLowerCase();
                const tokenM = lcCmd.match(tokenRegex);
                if (!tokenM) return 0;
                const tokenIdx = tokenM.index || 0;
                const tokenText = cmd.substr(tokenIdx, tokenM[0].length);
                const before = cmd.substring(0, tokenIdx);
                const afterStart = tokenIdx + tokenText.length;
                const nextPlaceholderIdx = cmd.indexOf('[', afterStart);
                const afterFixed = nextPlaceholderIdx === -1 ? cmd.substring(afterStart) : cmd.substring(afterStart, nextPlaceholderIdx);

                const beforeLc = before.toLowerCase();
                const q = (input || '').toLowerCase();
                if (!q.startsWith(beforeLc)) {
                    return longestCommonPrefixLen(lcCmd, q);
                }
                const typedAfterPrefix = q.length > beforeLc.length ? q.slice(beforeLc.length) : '';
                const afterFixedLc = (afterFixed || '').toLowerCase();
                let k = 0;
                if (afterFixedLc && typedAfterPrefix) {
                    const maxPref = Math.min(afterFixedLc.length, typedAfterPrefix.length);
                    for (let i2 = maxPref; i2 >= 1; i2--) {
                        if (typedAfterPrefix.endsWith(afterFixedLc.substring(0, i2))) { k = i2; break; }
                    }
                }
                const typedInsidePlaceholderLen = Math.max(0, typedAfterPrefix.length - k);
                const materialized = (before + typedAfterPrefix + afterFixed).toLowerCase();
                const cutoffMat = longestCommonPrefixLen(materialized, q);
                let cutoffTpl;
                if (cutoffMat <= before.length) {
                    cutoffTpl = cutoffMat;
                } else if (cutoffMat <= before.length + typedInsidePlaceholderLen) {
                    cutoffTpl = before.length + tokenText.length;
                } else {
                    const extra = cutoffMat - (before.length + typedInsidePlaceholderLen);
                    cutoffTpl = before.length + tokenText.length + extra;
                }
                return Math.max(0, Math.min(cutoffTpl, cmd.length));
            } catch (e) { return 0; }
        }

        function computeMaterializedDurationCutoff(cmd, input) {
            try {
                const tokenRegex = /\[(duration|time\s*frame|time\s*period|משך(?:\s*זמן)?|טווח(?:\s*זמן)?|פרק(?:\s*זמן)?)\]/i;
                const lcCmd = cmd.toLowerCase();
                const tokenM = lcCmd.match(tokenRegex);
                if (!tokenM) return 0;
                const tokenIdx = tokenM.index || 0;
                const tokenEnd = lcCmd.indexOf(']', tokenIdx) + 1;
                const tokenText = cmd.substring(tokenIdx, tokenEnd);
                let lastClose = cmd.lastIndexOf(']', tokenIdx - 1);
                if (lastClose < 0) lastClose = 0;
                const beforeFixed = lastClose > 0 ? cmd.substring(lastClose + 1, tokenIdx) : (cmd.substring(0, tokenIdx).split(/\[[^\]]+\]/).pop() || '');
                const beforeFixedLc = beforeFixed.toLowerCase();
                const q = (input || '').toLowerCase();
                const anchorPos = beforeFixedLc ? q.lastIndexOf(beforeFixedLc) : -1;
                if (beforeFixedLc && anchorPos === -1) return 0;
                const afterAnchor = beforeFixedLc ? q.slice(anchorPos + beforeFixedLc.length) : q;
                const afterStart = tokenEnd;
                const nextPlaceholderIdx = cmd.indexOf('[', afterStart);
                const afterFixed = nextPlaceholderIdx === -1 ? cmd.substring(afterStart) : cmd.substring(afterStart, nextPlaceholderIdx);
                const afterFixedLc = (afterFixed || '').toLowerCase();
                let k = 0;
                if (afterFixedLc && afterAnchor) {
                    const maxPref = Math.min(afterFixedLc.length, afterAnchor.length);
                    for (let i2 = maxPref; i2 >= 1; i2--) {
                        if (afterAnchor.endsWith(afterFixedLc.substring(0, i2))) { k = i2; break; }
                    }
                }
                const strongEnd = tokenIdx + tokenText.length + (k > 0 ? k : 0);
                return Math.max(0, Math.min(strongEnd, cmd.length));
            } catch (e) { return 0; }
        }

        // Prevent duplicate submissions and show overlay
        if (form) {
            form.addEventListener('submit', function(e) {
                if (isSubmitting) {
                    e.preventDefault();
                    return;
                }
                isSubmitting = true;
                if (overlay) overlay.style.display = 'flex';
                if (processBtn) processBtn.disabled = true;
                if (commandInput) commandInput.readOnly = true; // keep value posted
            });
        }

        if (commandInput) {
            commandInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && isSubmitting) {
                    e.preventDefault();
                }
            });
        }

        // Confirmation form: show overlay and prevent duplicate submits
        const confirmForm = document.getElementById('confirm-form');
        if (confirmForm) {
            confirmForm.addEventListener('submit', function(e) {
                if (isSubmitting) {
                    e.preventDefault();
                    return;
                }
                isSubmitting = true;
                if (overlay) overlay.style.display = 'flex';
                const confirmBtn = document.getElementById('confirm-btn');
                if (confirmBtn) confirmBtn.disabled = true;
            });
        }

        // Full stats form: show overlay and prevent duplicate submits
        const fullStatsForm = document.getElementById('full-stats-form');
        if (fullStatsForm) {
            fullStatsForm.addEventListener('submit', function(e) {
                if (isSubmitting) {
                    e.preventDefault();
                    return;
                }
                isSubmitting = true;
                if (overlay) overlay.style.display = 'flex';
                const fullBtn = document.getElementById('full-stats-btn');
                if (fullBtn) {
                    fullBtn.disabled = true;
                    fullBtn.textContent = i18n.i18nAnalyzing || 'Analyzing...';
                }
            });
        }

        // Undo forms: show overlay and prevent duplicate submits
        const undoForms = document.querySelectorAll('.undo-form');
        if (undoForms && undoForms.length) {
            undoForms.forEach(function(uf) {
                uf.addEventListener('submit', function(e) {
                    if (isSubmitting) {
                        e.preventDefault();
                        return;
                    }
                    isSubmitting = true;
                    if (overlay) overlay.style.display = 'flex';
                    const btn = uf.querySelector('.undo-btn');
                    if (btn) {
                        btn.disabled = true;
                        btn.textContent = i18n.i18nUndoing || 'Undoing...';
                    }
                });
            });
        }

        // Load more handler (progressive enhancement)
        const loadMoreForm = document.getElementById('load-more-form');
        if (loadMoreForm) {
            loadMoreForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const btn = document.getElementById('load-more-btn');
                const tokenEl = document.getElementById('load_more_token');
                const ctxEl = document.getElementById('list_context');
                const emailList = document.getElementById('email-list');
                const inline = document.getElementById('load-more-inline');
                if (!btn || !tokenEl || !ctxEl || !emailList) return;
                if (btn.disabled) return;
                btn.disabled = true;
                const oldText = btn.textContent;
                btn.textContent = i18n.i18nLoading || 'Loading...';
                if (inline) inline.style.display = 'inline';
                const formData = new FormData(loadMoreForm);
                fetch('', { method: 'POST', body: formData })
                    .then(r => r.json())
                    .then(data => {
                        const items = data.data || [];
                        items.forEach(item => {
                            const li = document.createElement('li');
                            li.className = 'email-item';
                            const sender = document.createElement('div');
                            sender.className = 'email-sender';
                            sender.setAttribute('dir','auto');
                            sender.textContent = item.sender || '';
                            const subject = document.createElement('div');
                            subject.className = 'email-subject';
                            subject.setAttribute('dir','auto');
                            subject.textContent = item.subject || '';
                            li.appendChild(sender);
                            li.appendChild(subject);
                            
                            // Add date if available
                            if (item.date) {
                                const date = document.createElement('div');
                                date.className = 'email-date';
                                date.textContent = item.date;
                                li.appendChild(date);
                            }
                            
                            emailList.appendChild(li);
                        });
                        if (items.length) {
                            const tmpl = i18n.i18nLoadedMoreWithCount || 'Loaded {count} more';
                            const msg = tmpl.replace('{count}', items.length);
                            showSnackbar(msg, 'success');
                        }
                        if (data.next_page_token) {
                            tokenEl.value = data.next_page_token;
                            btn.disabled = false;
                            btn.textContent = i18n.i18nLoadMore || 'Load more';
                        } else {
                            btn.disabled = true;
                            btn.textContent = i18n.i18nNoMoreResults || 'No more results';
                        }
                    })
                    .catch(() => {
                        btn.disabled = false;
                        btn.textContent = oldText;
                        showSnackbar(i18n.i18nFailedLoadMore || 'Failed to load more', 'error');
                    })
                    .finally(() => { if (inline) inline.style.display = 'none'; });
            });
        }

        // Overlay suggestions just under the input (with fuzzy fallback) + keyboard navigation
        let debounceTimer = null;
        let activeIndex = -1;
        let suggestionItems = [];
        let activeByKeyboard = false; // only accept Enter when set via arrows

        function positionSuggestions() {
            console.log('positionSuggestions called');
            if (!suggestionsContainer || !commandInput) {
                console.log('Missing elements - suggestionsContainer:', !!suggestionsContainer, 'commandInput:', !!commandInput);
                return;
            }
            try {
                // Get the input field's position
                const inputRect = commandInput.getBoundingClientRect();
                console.log('Input rect:', inputRect);
                
                // Always use the left edge of the input field, regardless of RTL/LTR
                // The CSS will handle the RTL alignment
                const left = inputRect.left;
                const top = inputRect.bottom + 4;
                const width = inputRect.width;
                
                console.log('Calculated position - left:', left, 'top:', top, 'width:', width);
                
                // Set position using fixed positioning
                suggestionsContainer.style.setProperty('position', 'fixed', 'important');
                suggestionsContainer.style.setProperty('left', left + 'px', 'important');
                suggestionsContainer.style.setProperty('top', top + 'px', 'important');
                suggestionsContainer.style.setProperty('width', width + 'px', 'important');
                suggestionsContainer.style.setProperty('z-index', '1000', 'important');
                
                console.log('Position set successfully');
            } catch(e) {
                console.error('Error positioning suggestions:', e);
            }
        }

        function renderSuggestions(input) {
            console.log('renderSuggestions called with input:', input);
            closeAllLists();
            activeIndex = -1;
            suggestionItems = [];
            activeByKeyboard = false;
            if (!input) return;
            console.log('Creating autocomplete suggestions container...');
            suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'autocomplete-suggestions';
            suggestionsContainer.setAttribute('role','listbox');
            const wrapper = commandInput.parentNode;
            wrapper.style.position = 'relative';
            wrapper.appendChild(suggestionsContainer);
            console.log('Calling positionSuggestions...');
            positionSuggestions();

            const maxShow = 12;
            const items = getSuggestions(input.toLowerCase(), maxShow);
            items.forEach((item, idx) => {
                const { cmd, type } = item;
                const div = document.createElement('div');
                div.setAttribute('role','option');
                div.style.padding = '10px';
                div.style.cursor = 'pointer';
                const lc = cmd.toLowerCase();
                const pos = lc.indexOf(input.toLowerCase());

                // Force placeholder-aware bolding for sender and duration/timeframe tokens
                const hasSenderToken = /\[(sender(?:\/domain)?|domain(?:\.com)?|שולח(?:\/דומיין)?|דומיין)\]/i.test(cmd);
                const hasDurationToken = /\[(duration|time\s*frame|time\s*period|משך(?:\s*זמן)?|טווח(?:\s*זמן)?|פרק(?:\s*זמן)?)\]/i.test(cmd);
                if (hasSenderToken) {
                    // Only apply sender-aware bolding if user typed a sender cue (e.g., "from"/"מ-")
                    const qlAll = (input || '').toLowerCase();
                    const partialFromCue = /\blist\s+emails\s+f(?:r|ro)?$/i.test(qlAll);
                    let hasSenderCue = /\bfrom\b|\bמ(?:-|\s)/i.test(qlAll) || partialFromCue;
                    // If a timeframe token follows a full 'from', suppress sender cue
                    try {
                        const mTok = qlAll.match(/\bfrom\s+([a-z0-9\.\-]+)/i);
                        if (mTok && mTok[1]) {
                            const tok = mTok[1];
                            if (!/[.]/.test(tok)) {
                                const timePrefixes = ['today','yesterday','last','this'];
                                if (/^\d/.test(tok) || timePrefixes.some(w => w.startsWith(tok))) {
                                    hasSenderCue = false;
                                }
                            }
                        }
                    } catch (e) {}
                    if (!hasSenderCue) {
                        // Allow simple per-letter bold for the fixed prefix when there's no sender cue
                        const qlPrefix = (input || '').toLowerCase();
                        const lcCmdPrefix = cmd.toLowerCase();
                        if (lcCmdPrefix.startsWith(qlPrefix)) {
                            const bold = escapeHtml(cmd.substring(0, qlPrefix.length));
                            const rest = escapeHtml(cmd.substring(qlPrefix.length));
                            div.innerHTML = `<strong>${bold}</strong>${rest}`;
                        } else {
                            div.textContent = cmd;
                        }
                    } else {
                    // Try materialized rendering first; if it succeeds, we're done for this item
                    if (renderSenderMaterialized(div, cmd, input)) {
                        // keep click/select handlers below
                    } else {
                    const ql = (input || '').toLowerCase();
                    const lcCmd2 = cmd.toLowerCase();
                    const tokenRegex = /\[(sender(?:\/domain)?|domain(?:\.com)?|שולח(?:\/דומיין)?|דומיין)\]/i;
                    const tokenMatch = lcCmd2.match(tokenRegex);
                    const tokenIdx = tokenMatch ? tokenMatch.index : -1;
                    let boldLen;
                    if (tokenIdx >= 0) {
                        // Determine fixed parts around sender token using indices to avoid ambiguity
                        const before = cmd.substring(0, tokenIdx);
                        const beforeLc = before.toLowerCase();
                        const afterStart = tokenIdx + tokenMatch[0].length;
                        const nextPlaceholderIdx = cmd.indexOf('[', afterStart);
                        const afterFixed = nextPlaceholderIdx === -1 ? cmd.substring(afterStart) : cmd.substring(afterStart, nextPlaceholderIdx);
                        const afterFixedLc = afterFixed.toLowerCase();

                        // 1) If still typing the fixed prefix (including partial 'from'), bold only that much
                        let matched = 0;
                        while (matched < beforeLc.length && matched < ql.length && ql.charAt(matched) === beforeLc.charAt(matched)) matched++;
                        if (matched < beforeLc.length) {
                            const bold = escapeHtml(cmd.substring(0, matched));
                            const rest = escapeHtml(cmd.substring(matched));
                            div.innerHTML = `<strong>${bold}</strong>${rest}`;
                        } else {
                            // 2) Inside/after sender: compute how much of the next fixed segment is typed
                            const typedInside = ql.slice(beforeLc.length); // from start of placeholder
                            let k = 0;
                            const maxPref = Math.min(afterFixedLc.length, typedInside.length);
                            for (let i2 = maxPref; i2 >= 1; i2--) {
                                if (typedInside.endsWith(afterFixedLc.substring(0, i2))) { k = i2; break; }
                            }
                            const strongEnd = afterStart + k; // include [sender] and k chars of next fixed
                            const bold = escapeHtml(cmd.substring(0, strongEnd));
                            const rest = escapeHtml(cmd.substring(strongEnd));
                            div.innerHTML = `<strong>${bold}</strong>${rest}`;
                        }
                        
                    } else {
                        boldLen = item.prefixLen || 0;
                    }
                    const safeBoldLen = Math.max(0, Math.min(boldLen, cmd.length));
                    const bold = escapeHtml(cmd.substring(0, safeBoldLen));
                    const rest = escapeHtml(cmd.substring(safeBoldLen));
                    div.innerHTML = `<strong>${bold}</strong>${rest}`;
                    }
                    // Additionally extend into duration/timeframe ONLY after user types beyond the next fixed word
                    if (/\[(duration|time\s*frame|time\s*period|משך(?:\s*זמן)?|טווח(?:\s*זמן)?|פרק(?:\s*זמן)?)\]/i.test(cmd)) {
                        try {
                            const ql2 = (input || '').toLowerCase();
                            const lcCmd3 = cmd.toLowerCase();
                            const senderRe = /\[(sender(?:\/domain)?|domain(?:\.com)?|שולח(?:\/דומיין)?|דומיין)\]/i;
                            const m = lcCmd3.match(senderRe);
                            if (m) {
                                const tokenIdx2 = m.index || 0;
                                const before2 = cmd.substring(0, tokenIdx2).toLowerCase();
                                const afterStart2 = tokenIdx2 + m[0].length;
                                const nextPH2 = cmd.indexOf('[', afterStart2);
                                const afterFixed2 = (nextPH2 === -1 ? cmd.substring(afterStart2) : cmd.substring(afterStart2, nextPH2)).toLowerCase();
                                const typedInside2 = ql2.length > before2.length ? ql2.slice(before2.length) : '';
                                let k2 = 0; const max2 = Math.min(afterFixed2.length, typedInside2.length);
                                for (let i2 = max2; i2 >= 1; i2--) { if (typedInside2.endsWith(afterFixed2.substring(0, i2))) { k2 = i2; break; } }
                                const fullyMatchedNextFixed = afterFixed2.length > 0 && k2 >= afterFixed2.length;
                                const hasTypedBeyondNextFixed = fullyMatchedNextFixed && (typedInside2.length > k2);
                                if (hasTypedBeyondNextFixed) {
                                    renderDurationMaterialized(div, cmd, input);
                                }
                            }
                        } catch (e) { /* ignore */ }
                    }
                    }
                } else if (hasDurationToken) {
                    // Mirror behavior for duration/timeframe tokens
                    if (renderDurationMaterialized(div, cmd, input)) {
                        // done
                    } else {
                        // Only bold if input is a strict prefix of the command
                        const ql = (input || '').toLowerCase();
                        const lcCmd2 = cmd.toLowerCase();
                        if (lcCmd2.startsWith(ql)) {
                            const bold = escapeHtml(cmd.substring(0, ql.length));
                            const rest = escapeHtml(cmd.substring(ql.length));
                            div.innerHTML = `<strong>${bold}</strong>${rest}`;
                        } else {
                            div.textContent = cmd;
                        }
                    }
                } else if (type === 'include' && pos >= 0) {
                    // Only bold includes when it's a true prefix match
                    if (pos === 0) {
                        const bold = escapeHtml(cmd.substring(0, input.length));
                        const rest = escapeHtml(cmd.substring(input.length));
                        div.innerHTML = `<strong>${bold}</strong>${rest}`;
                    } else {
                        div.textContent = cmd;
                    }
                } else if (type === 'placeholder') {
                    // Sender-first experience: explicitly bold through the sender/domain token as user types into it
                    const ql = (input || '').toLowerCase();
                    const lcCmd = cmd.toLowerCase();
                    const senderTokens = ['[sender]', '[domain.com]', '[שולח]', '[דומיין]'];
                    let tokenIdx = -1;
                    let tokenText = '';
                    for (let t of senderTokens) {
                        const idx = lcCmd.indexOf(t);
                        if (idx !== -1 && (tokenIdx === -1 || idx < tokenIdx)) { tokenIdx = idx; tokenText = cmd.substr(idx, t.length); }
                    }
                    let boldLen;
                    if (tokenIdx >= 0) {
                        const before = cmd.substring(0, tokenIdx);
                        const beforeLc = before.toLowerCase();
                        // Guard: if next fixed word diverges from typed word (>=2 chars), avoid bold
                        const parts = lcCmd.split(/\[[^\]]+\]/);
                        const nextFixed = parts[1] || '';
                        const nextWord = (nextFixed.trim().match(/^[a-z\u0590-\u05FF]+/i) || [''])[0].toLowerCase();
                        const typedAfter = ql.slice(beforeLc.length).trimLeft();
                        const typedWord = (typedAfter.match(/^[a-z0-9\u0590-\u05FF]+/i) || [''])[0].toLowerCase();
                        const earlyMismatch = typedWord.length >= 2 && nextWord && !nextWord.startsWith(typedWord);
                        let matched = 0;
                        while (matched < beforeLc.length && matched < ql.length && ql.charAt(matched) === beforeLc.charAt(matched)) matched++;
                        if (earlyMismatch) {
                            boldLen = 0;
                        } else {
                            // If user has started typing beyond the fixed prefix, include the whole token in bold
                            if (ql.length > beforeLc.length) boldLen = before.length + tokenText.length;
                            else boldLen = matched;
                        }
                    } else {
                        // Fallback to generic placeholder-aware bolding
                        boldLen = computePlaceholderBoldLength(cmd, input);
                    }
                    const safeBoldLen = Math.max(0, Math.min((boldLen != null ? boldLen : (item.prefixLen || 0)), cmd.length));
                    if (safeBoldLen > 0) {
                        const bold = cmd.substring(0, safeBoldLen);
                        const rest = cmd.substring(safeBoldLen);
                        div.innerHTML = `<strong>${bold}</strong>${rest}`;
                    } else {
                        div.textContent = cmd;
                    }
                } else {
                    div.textContent = cmd;
                }
                div.addEventListener('mouseenter', () => {
                    setActive(idx);
                    activeByKeyboard = false;
                });
                div.addEventListener('click', () => {
                    commandInput.value = cmd;
                    closeAllLists();
                    commandInput.focus();
                });
                suggestionsContainer.appendChild(div);
                suggestionItems.push(div);
            });
        }

        function setActive(index) {
            if (!suggestionItems.length) return;
            removeActive();
            if (index < 0) {
                activeIndex = suggestionItems.length - 1;
            } else if (index >= suggestionItems.length) {
                activeIndex = 0;
            } else {
                activeIndex = index;
            }
            const el = suggestionItems[activeIndex];
            if (el) {
                el.classList.add('active');
                el.setAttribute('aria-selected','true');
                el.scrollIntoView({block:'nearest'});
            }
        }

        function removeActive() {
            suggestionItems.forEach(el => {
                el.classList.remove('active');
                el.removeAttribute('aria-selected');
            });
        }



        commandInput.addEventListener('input', function() {
            const val = this.value || '';
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                renderSuggestions(val);
            }, 80);
        });

        commandInput.addEventListener('keydown', function(e) {
            if (!suggestionsContainer) {
                if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                    renderSuggestions(this.value || '');
                } else {
                    return;
                }
            }
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                setActive(activeIndex + 1);
                activeByKeyboard = true;
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                setActive(activeIndex - 1);
                activeByKeyboard = true;
            } else if (e.key === 'Enter') {
                if (suggestionItems.length && activeIndex >= 0 && activeByKeyboard) {
                    e.preventDefault();
                    const el = suggestionItems[activeIndex];
                    const text = el ? el.textContent : '';
                    if (text) commandInput.value = text;
                    closeAllLists();
                }
            } else if (e.key === 'Tab') {
                if (suggestionItems.length) {
                    const first = suggestionItems[0];
                    const text = first ? first.textContent : '';
                    if (text) commandInput.value = text;
                    closeAllLists();
                }
            } else if (e.key === 'Escape') {
                closeAllLists();
            }
        });

        window.addEventListener('resize', positionSuggestions);

        // Insert command into input
        window.insertCommand = function(cmd) {
            const ci = document.getElementById('command-input');
            if (ci) {
                ci.value = cmd || '';
                ci.focus();
            }
        }

        // Remove any existing suggestion overlay
        function closeAllLists() {
            if (suggestionsContainer && suggestionsContainer.parentNode) {
                suggestionsContainer.parentNode.removeChild(suggestionsContainer);
                suggestionsContainer = null;
            }
        }

        // Close overlay suggestions when clicking elsewhere
        document.addEventListener('click', function (e) {
            if (!e.target || (e.target !== commandInput && !e.target.closest('.autocomplete-suggestions'))) {
                closeAllLists();
            }
        });

        // Quick Commands inline autocomplete
        console.log('=== QUICK COMMANDS AUTCOMPLETE INITIALIZING ===');
        const favInput = document.getElementById('fav-input');
        let favInlineSuggestion = null;
        
        console.log('favInput found:', favInput);
        console.log('commands array length:', commands.length);
        console.log('Sample commands:', commands.slice(0, 3));

        function showFavInlineSuggestion(input) {
            if (!input || input.length < 2) {
                hideFavInlineSuggestion();
                return;
            }
            
            const bestMatch = getBestFavInlineSuggestion(input);
            if (bestMatch && bestMatch.cmd !== input) {
                showFavInlineSuggestionText(bestMatch.cmd, input);
            } else {
                hideFavInlineSuggestion();
            }
        }

        function getBestFavInlineSuggestion(input) {
            const q = input.toLowerCase().trim();
            let bestMatch = null;
            let bestScore = 0;
            
            // First try to find commands that start with the input
            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];
                const lc = cmd.toLowerCase();
                if (lc.startsWith(q)) {
                    // Prioritize shorter commands and common ones
                    let score = 1.0;
                    
                    // Bonus for shorter commands (easier to type)
                    score += (20 - cmd.length) * 0.01;
                    
                    // Bonus for common commands (list, send, delete, etc.)
                    if (cmd.includes('recent') || cmd.includes('send') || cmd.includes('delete') || 
                        cmd.includes('archive') || cmd.includes('stats')) {
                        score += 0.1;
                    }
                    
                    // Bonus for exact word matches
                    if (q === 'list' && cmd.includes('recent')) score += 0.2;
                    if (q === 'send' && cmd.includes('email')) score += 0.2;
                    if (q === 'delete' && cmd.includes('promotions')) score += 0.2;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = { cmd, score };
                    }
                }
            }
            
            // If no exact start match, try partial matches
            if (!bestMatch) {
                for (let i = 0; i < commands.length; i++) {
                    const cmd = commands[i];
                    const lc = cmd.toLowerCase();
                    if (lc.includes(q)) {
                        // Lower score for partial matches, but still prioritize shorter commands
                        let score = 0.7 + (20 - cmd.length) * 0.005;
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = { cmd, score };
                        }
                    }
                }
            }
            
            return bestMatch;
        }

        function showFavInlineSuggestionText(fullCommand, partialInput) {
            console.log('showFavInlineSuggestionText called with:', fullCommand, partialInput);
            hideFavInlineSuggestion();
            
            // Create a simple suggestion span
            const suggestionSpan = document.createElement('span');
            suggestionSpan.id = 'fav-inline-suggestion';
            suggestionSpan.className = 'fav-inline-suggestion';
            suggestionSpan.textContent = fullCommand.substring(partialInput.length);
            console.log('Suggestion text:', suggestionSpan.textContent);
            
            // Insert the suggestion right after the input
            favInput.parentNode.insertBefore(suggestionSpan, favInput.nextSibling);
            
            // Position it relative to the input's parent container
            const inputStyle = window.getComputedStyle(favInput);
            const paddingLeft = parseInt(inputStyle.paddingLeft);
            const paddingTop = parseInt(inputStyle.paddingTop);
            const textWidth = getFavTextWidth(partialInput, favInput);
            
            // Calculate available width to prevent overflow
            const inputWidth = favInput.offsetWidth;
            const paddingRight = parseInt(inputStyle.paddingRight);
            const availableWidth = inputWidth - paddingLeft - paddingRight - textWidth - 10; // Reduced buffer to 10px
            
            // Check if we're in Hebrew mode (RTL)
            const isHebrew = document.documentElement.dir === 'rtl' || document.documentElement.lang === 'he';
            
            suggestionSpan.style.position = 'absolute';
            if (isHebrew) {
                // For Hebrew (RTL), position it to the RIGHT of the text
                // Position it based on text width to make it follow your typing
                suggestionSpan.style.right = (paddingRight + textWidth + 2) + 'px';
                suggestionSpan.style.left = 'auto';
                suggestionSpan.style.fontSize = '0.75em'; // Smaller font for Hebrew suggestions
            } else {
                // For English (LTR), position it to the LEFT of the text
                suggestionSpan.style.left = (paddingLeft + textWidth + 2) + 'px';
                suggestionSpan.style.right = 'auto';
            }
            suggestionSpan.style.top = paddingTop + 'px'; // Perfect alignment
            suggestionSpan.style.zIndex = '1000';
            suggestionSpan.style.color = '#888';
            
            // Always show the suggestion, but adjust positioning if needed
            const suggestionText = suggestionSpan.textContent;
            const suggestionWidth = getFavTextWidth(suggestionText, favInput);
            
            // If suggestion is too wide, truncate it but always show something
            if (suggestionWidth > availableWidth) {
                let truncatedText = suggestionText;
                while (truncatedText.length > 0 && getFavTextWidth(truncatedText + '...', favInput) > availableWidth) {
                    truncatedText = truncatedText.slice(0, -1);
                }
                if (truncatedText.length > 0) {
                    suggestionSpan.textContent = truncatedText + '...';
                } else {
                    // Even if we can only show a few characters, show them
                    suggestionSpan.textContent = suggestionText.substring(0, 3) + '...';
                }
            }
            
            // Position suggestion to align with your text, but ensure it fits
            let finalLeft = paddingLeft + textWidth + 2;
            let remainingSpace = inputWidth - paddingRight - finalLeft - 10;
            
            // Always ensure suggestion fits within available space
            if (suggestionWidth > remainingSpace) {
                // Calculate exactly how many characters can fit
                let charWidth = suggestionWidth / suggestionText.length;
                let maxChars = Math.floor(remainingSpace / charWidth);
                
                if (maxChars > 0) {
                    // Truncate to fit exactly in remaining space
                    suggestionSpan.textContent = suggestionText.substring(0, maxChars) + '...';
                } else {
                    // Even one character won't fit - hide suggestion
                    suggestionSpan.remove();
                    return;
                }
            }
            
            suggestionSpan.style.left = finalLeft + 'px';
            suggestionSpan.style.maxWidth = remainingSpace + 'px';
            
            console.log('Suggestion positioned at:', suggestionSpan.style.left, suggestionSpan.style.top);
            console.log('Suggestion element:', suggestionSpan);
        }

        function hideFavInlineSuggestion() {
            const existing = document.getElementById('fav-inline-suggestion');
            if (existing) {
                existing.remove();
            }
        }

        function getFavTextWidth(text, element) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = window.getComputedStyle(element).font;
            return context.measureText(text).width;
        }
        
        // Test function - call this in console to test
        function testFavAutocomplete() {
            console.log('Testing fav autocomplete...');
            if (favInput) {
                favInput.value = 'list';
                favInput.dispatchEvent(new Event('input'));
            } else {
                console.log('favInput not found!');
            }
        }

        // Add event listeners for quick commands input
        if (favInput) {
            console.log('Setting up event listeners for favInput');
            // Ensure the input wrapper has relative positioning
            const inputWrapper = favInput.parentNode;
            inputWrapper.style.position = 'relative';
            
            favInput.addEventListener('input', function() {
                const val = this.value || '';
                console.log('Input value:', val);
                if (val.length > 0) {
                    const bestMatch = getBestFavInlineSuggestion(val);
                    console.log('Best match:', bestMatch);
                    if (bestMatch && bestMatch.score > 0.5) {
                        console.log('Showing suggestion for:', bestMatch.cmd);
                        showFavInlineSuggestionText(bestMatch.cmd, val);
                    } else {
                        console.log('No good match, hiding suggestion');
                        hideFavInlineSuggestion();
                    }
                } else {
                    console.log('Empty input, hiding suggestion');
                    hideFavInlineSuggestion();
                }
            });

            favInput.addEventListener('keydown', function(e) {
                if (e.key === 'Tab') {
                    // Accept inline suggestion if available
                    const inlineSuggestion = document.getElementById('fav-inline-suggestion');
                    if (inlineSuggestion) {
                        const currentValue = favInput.value;
                        // Get the full command from the original best match, not the truncated suggestion
                        const bestMatch = getBestFavInlineSuggestion(currentValue);
                        if (bestMatch) {
                            favInput.value = bestMatch.cmd;
                        } else {
                            // Fallback to suggestion text if no match found
                            const suggestionText = inlineSuggestion.textContent;
                            favInput.value = currentValue + suggestionText;
                        }
                        hideFavInlineSuggestion();
                        e.preventDefault();
                    }
                } else if (e.key === 'ArrowRight') {
                    // Accept inline suggestion if available
                    const inlineSuggestion = document.getElementById('fav-inline-suggestion');
                    if (inlineSuggestion) {
                        const currentValue = favInput.value;
                        // Get the full command from the original best match, not the truncated suggestion
                        const bestMatch = getBestFavInlineSuggestion(currentValue);
                        if (bestMatch) {
                            favInput.value = bestMatch.cmd;
                        } else {
                            // Fallback to suggestion text if no match found
                            const suggestionText = inlineSuggestion.textContent;
                            favInput.value = currentValue + suggestionText;
                        }
                        hideFavInlineSuggestion();
                        e.preventDefault();
                    }
                } else if (e.key === 'Escape') {
                    hideFavInlineSuggestion();
                }
            });

            // Hide suggestion when clicking elsewhere
            favInput.addEventListener('blur', function() {
                setTimeout(hideFavInlineSuggestion, 100);
            });
        }

        // Compose To: custom contact suggestions
        const composeForm = document.getElementById('compose-form');
        const toInput = composeForm ? composeForm.querySelector('input[name="compose_to"]') : null;
        let contactsBox = null;
        let contactsItems = [];
        let contactsActive = -1;
        let contactsDebounce = null;

        function closeContacts() {
            if (contactsBox && contactsBox.parentNode) {
                contactsBox.parentNode.removeChild(contactsBox);
                contactsBox = null;
                contactsItems = [];
                contactsActive = -1;
            }
        }
        function positionContacts() {
            if (!toInput || !contactsBox) return;
            const r = toInput.getBoundingClientRect();
            const parentRect = toInput.offsetParent ? toInput.offsetParent.getBoundingClientRect() : {left:0,top:0};
            contactsBox.style.left = (toInput.offsetLeft) + 'px';
            contactsBox.style.top = (toInput.offsetTop + toInput.offsetHeight) + 'px';
            contactsBox.style.width = toInput.offsetWidth + 'px';
        }
        function renderContacts(list) {
            closeContacts();
            if (!toInput || !Array.isArray(list) || !list.length) return;
            const wrapper = toInput.parentNode;
            wrapper.style.position = 'relative';
            contactsBox = document.createElement('div');
            contactsBox.className = 'contact-suggestions';
            contactsBox.setAttribute('role','listbox');
            wrapper.appendChild(contactsBox);
            positionContacts();
            list.forEach((c, idx) => {
                const div = document.createElement('div');
                div.setAttribute('role','option');
                const nm = (c.name || '').trim();
                const em = (c.email || '').trim();
                const left = document.createElement('span');
                left.className = 'contact-text';
                left.textContent = nm ? (nm + ' <' + em + '>') : em;
                const remove = document.createElement('span');
                remove.textContent = '×';
                remove.className = 'contact-remove';
                remove.title = 'Hide this contact';
                remove.addEventListener('click', function(e){
                    e.stopPropagation();
                    hideContact(em).then(() => {
                        // Refresh suggestions with current query
                        const q = (toInput.value || '').trim();
                        fetchContacts(q).then(renderContacts);
                    });
                });
                div.addEventListener('mouseenter', () => { setActiveContact(idx); });
                div.addEventListener('click', () => {
                    toInput.value = em;
                    closeContacts();
                    toInput.focus();
                });
                div.appendChild(left);
                div.appendChild(remove);
                contactsBox.appendChild(div);
                contactsItems.push(div);
            });
        }
        function setActiveContact(idx) {
            if (!contactsItems.length) return;
            contactsItems.forEach(el => { el.classList.remove('active'); el.removeAttribute('aria-selected'); });
            if (idx < 0) idx = contactsItems.length - 1;
            if (idx >= contactsItems.length) idx = 0;
            contactsActive = idx;
            const el = contactsItems[contactsActive];
            if (el) { el.classList.add('active'); el.setAttribute('aria-selected','true'); el.scrollIntoView({block:'nearest'}); }
        }
        // Prefetch contacts once for instant filtering
        let cachedContacts = [];
        let prefetchPromise = null;
        const CONTACTS_CACHE_KEY = 'contactsCacheV1';
        // Seed cache from localStorage/sessionStorage for instant first paint
        try {
            const savedLocal = localStorage.getItem(CONTACTS_CACHE_KEY);
            const savedSession = sessionStorage.getItem(CONTACTS_CACHE_KEY);
            const saved = savedLocal || savedSession;
            if (saved) {
                const parsed = JSON.parse(saved);
                if (Array.isArray(parsed)) { cachedContacts = parsed; }
            }
        } catch (e) { /* ignore storage errors */ }
        function fetchWithTimeout(resource, options) {
            const { timeout = 1500 } = options || {};
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            return fetch(resource, { ...options, signal: controller.signal })
                .finally(() => clearTimeout(id));
        }
        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
            return '';
        }
        function fetchContacts(q) {
            const fd = new FormData();
            fd.append('get_contacts', '1');
            fd.append('q', q || '');
            fd.append('limit', '50');
            // CSRF token from cookie fallback to hidden input
            let csrf = getCookie('csrftoken');
            if (!csrf && composeForm) {
                const input = composeForm.querySelector('input[name="csrfmiddlewaretoken"]');
                csrf = input ? input.value : '';
            }
            const headers = csrf && csrf.length > 20 ? {'X-CSRFToken': csrf, 'X-Requested-With': 'XMLHttpRequest'} : {'X-Requested-With': 'XMLHttpRequest'};
            return fetchWithTimeout('', { method: 'POST', headers, body: fd, credentials: 'same-origin', timeout: 3000 })
                .then(r => r.json())
                .then(d => Array.isArray(d.contacts) ? d.contacts : [])
                .catch(() => []);
        }
        function prefetchContacts() {
            if (prefetchPromise) return prefetchPromise;
            prefetchPromise = fetchContacts('')
                .then(list => {
                    if (Array.isArray(list) && list.length) {
                        cachedContacts = list;
                        try {
                            const payload = JSON.stringify(list);
                            sessionStorage.setItem(CONTACTS_CACHE_KEY, payload);
                            localStorage.setItem(CONTACTS_CACHE_KEY, payload);
                        } catch (e) { /* ignore */ }
                    }
                    return list;
                })
                .catch(() => {
                    // Keep whatever we have in cache
                    return cachedContacts;
                });
            return prefetchPromise;
        }
        function hideContact(email) {
            const fd = new FormData();
            fd.append('hide_contact', '1');
            fd.append('email', email || '');
            let csrf = getCookie('csrftoken');
            if (!csrf && composeForm) {
                const input = composeForm.querySelector('input[name="csrfmiddlewaretoken"]');
                csrf = input ? input.value : '';
            }
            const headers = csrf && csrf.length > 20 ? {'X-CSRFToken': csrf, 'X-Requested-With': 'XMLHttpRequest'} : {'X-Requested-With': 'XMLHttpRequest'};
            return fetch('', { method: 'POST', headers, body: fd, credentials: 'same-origin' })
                .then(r => r.json())
                .catch(() => ({}));
        }
        // Kick off prefetch immediately so it warms before user interaction
        prefetchContacts();
        if (toInput) {
            toInput.setAttribute('autocomplete', 'off');
            // Prefetch early so first keystroke is instant; also prefetch on load
            prefetchContacts();
            window.addEventListener('load', function(){ prefetchContacts(); });
            // Also prefetch on pageshow (when navigating back/forward without full reload)
            window.addEventListener('pageshow', function(){
                prefetchContacts();
            });
            // Refocus handler to ensure suggestions render after language switch without reload
            document.addEventListener('visibilitychange', function(){
                if (!document.hidden && document.activeElement === toInput && (!contactsBox)) {
                    const q = (toInput.value || '').trim();
                    prefetchContacts().then(() => {
                        if (q) {
                            const lc = q.toLowerCase();
                            const filtered = (cachedContacts || []).filter(c => {
                                const em = (c.email||'').toLowerCase();
                                const nm = (c.name||'').toLowerCase();
                                return em.includes(lc) || (nm && nm.includes(lc));
                            }).slice(0, 20);
                            renderContacts(filtered);
                        } else {
                            renderContacts((cachedContacts || []).slice(0, 20));
                        }
                    });
                }
            });
            // Show suggestions on focus (before typing)
            toInput.addEventListener('focus', function() {
                const q = (this.value || '').trim();
                prefetchContacts().then(() => {
                    if (q) {
                        const lc = q.toLowerCase();
                        const filtered = (cachedContacts || []).filter(c => {
                            const em = (c.email||'').toLowerCase();
                            const nm = (c.name||'').toLowerCase();
                            return em.includes(lc) || (nm && nm.includes(lc));
                        }).slice(0, 20);
                        renderContacts(filtered);
                    } else {
                        renderContacts((cachedContacts || []).slice(0, 20));
                    }
                });
            });
            let bgFetchTimer = null;
            let lastFetchQuery = '';
            toInput.addEventListener('input', function() {
                const q = (this.value || '').trim();
                if (!q) { closeContacts(); return; }
                
                // Always filter cached contacts instantly
                const lc = q.toLowerCase();
                const filtered = cachedContacts.filter(c => {
                    const em = (c.email||'').toLowerCase();
                    const nm = (c.name||'').toLowerCase();
                    return em.includes(lc) || (nm && nm.includes(lc));
                }).slice(0, 20);
                renderContacts(filtered);
                
                // If cache is empty, try to prefetch in background
                if (cachedContacts.length === 0) {
                    prefetchContacts().then(() => {
                        // Re-filter with fresh cache
                        const freshFiltered = cachedContacts.filter(c => {
                            const em = (c.email||'').toLowerCase();
                            const nm = (c.name||'').toLowerCase();
                            return em.includes(lc) || (nm && nm.includes(lc));
                        }).slice(0, 20);
                        renderContacts(freshFiltered);
                    });
                }

                // Background fallback: if few matches or query looks like an email, try server
                if (filtered.length <= 5 || q.indexOf('@') !== -1) {
                    clearTimeout(bgFetchTimer);
                    bgFetchTimer = setTimeout(() => {
                        const currentQ = (toInput.value || '').trim();
                        if (currentQ !== q) return; // stale
                        if (lastFetchQuery === q) return; // already fetched
                        lastFetchQuery = q;
                        fetchContacts(q).then(serverList => {
                            // Merge server results into cache (by email uniqueness)
                            if (Array.isArray(serverList) && serverList.length) {
                                const byEmail = new Map();
                                cachedContacts.forEach(c => { const em = (c.email||'').toLowerCase(); byEmail.set(em, c); });
                                serverList.forEach(c => { const em = (c.email||'').toLowerCase(); if (em) byEmail.set(em, c); });
                                cachedContacts = Array.from(byEmail.values());
                                try { sessionStorage.setItem(CONTACTS_CACHE_KEY, JSON.stringify(cachedContacts)); } catch (e) { /* ignore */ }
                                // Re-filter and update view only if still on same query
                                const nowQ = (toInput.value || '').trim().toLowerCase();
                                if (nowQ === q.toLowerCase()) {
                                    const updated = cachedContacts.filter(c => {
                                        const em = (c.email||'').toLowerCase();
                                        const nm = (c.name||'').toLowerCase();
                                        return em.includes(lc) || (nm && nm.includes(lc));
                                    }).slice(0, 20);
                                    renderContacts(updated);
                                }
                            }
                        });
                    }, 150);
                }
            });
            toInput.addEventListener('keydown', function(e) {
                if (!contactsBox) return;
                if (e.key === 'ArrowDown') { e.preventDefault(); setActiveContact(contactsActive + 1); }
                else if (e.key === 'ArrowUp') { e.preventDefault(); setActiveContact(contactsActive - 1); }
                else if (e.key === 'Enter') {
                    if (contactsActive >= 0 && contactsItems[contactsActive]) {
                        e.preventDefault();
                        const text = contactsItems[contactsActive].textContent || '';
                        // extract email from "Name <email>"
                        const m = text.match(/<([^>]+)>/);
                        const em = m ? m[1] : text;
                        toInput.value = em.trim();
                        closeContacts();
                    }
                } else if (e.key === 'Escape') { closeContacts(); }
            });
            document.addEventListener('click', function(e){
                if (!e.target || (e.target !== toInput && !e.target.closest('.contact-suggestions'))) {
                    closeContacts();
                }
            });
            window.addEventListener('resize', positionContacts);
        }



        // Enhanced form submission with loading screens
        document.getElementById('command-form').addEventListener('submit', function(e) {
            console.log('Form submitted!'); // Debug log
            
            const commandInput = document.getElementById('command-input');
            if (!commandInput) {
                console.log('Command input not found');
                return true;
            }
            
            const command = commandInput.value.toLowerCase().trim();
            console.log('Command:', command); // Debug log
            
            // Skip loading screen for empty commands (they just refresh instantly)
            if (!command) {
                console.log('Empty command, submitting immediately without loading screen');
                document.getElementById('command-form').submit();
                return;
            }
            
            // Generate unique command ID for progress tracking
            const commandId = 'cmd_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Show loading screen and submit form immediately
            if (command.includes('show email stats') || command.includes('show stats') || 
                command.includes('הצג סטטיסטיק') || command.includes('הראה סטטיסטיק') || 
                command.includes('סטטיסטיק')) {
                console.log('Showing stats loading screen'); // Debug log
                showStatsLoadingScreen();
                
                // Connect to real-time progress updates for stats
                connectToProgressStream(commandId, 'stats');
                
                // Fallback: Start a simple progress animation for stats in case SSE fails
                let fallbackStatsProgress = 0;
                const fallbackStatsInterval = setInterval(() => {
                    fallbackStatsProgress += Math.random() * 0.5 + 0.3; // 0.3-0.8% increments (slower for stats)
                    if (fallbackStatsProgress > 95) fallbackStatsProgress = 95;
                    updateStatsProgress(fallbackStatsProgress, '{% trans "Processing emails..." %}');
                }, 500);
                
                // Store interval for cleanup
                window.fallbackStatsProgressInterval = fallbackStatsInterval;
                
            } else if (command.includes('list recent emails') || command.includes('list archived emails') || 
                       command.includes('list all mail') || command.includes('list emails from') ||
                       command.includes('רשום מיילים אחרונים') || command.includes('רשום מיילים מארכיון') || 
                       command.includes('רשום כל המיילים') || command.includes('רשום מיילים מ')) {
                console.log('Showing email listing loading screen'); // Debug log
                showEmailListingLoadingScreen();
                
                // Connect to real-time progress updates for email listing
                connectToProgressStream(commandId, 'stats');
                
                // Fallback: Start a simple progress animation for email listing in case SSE fails
                let fallbackEmailProgress = 0;
                const fallbackEmailInterval = setInterval(() => {
                    fallbackEmailProgress += Math.random() * 0.8 + 0.5; // 0.5-1.3% increments (faster for email listing)
                    if (fallbackEmailProgress > 95) fallbackEmailProgress = 95;
                    updateStatsProgress(fallbackEmailProgress, '{% trans "Searching emails..." %}');
                }, 400);
                
                // Store interval for cleanup
                window.fallbackEmailProgressInterval = fallbackEmailInterval;
                
            } else {
                console.log('Showing general loading screen'); // Debug log
                
                // General loading screen for other commands
                const commandMessages = {
                    'list': '{% trans "Fetching your emails..." %}',
                    'search': '{% trans "Searching through emails..." %}',
                    'delete': '{% trans "Processing deletion..." %}',
                    'archive': '{% trans "Archiving emails..." %}',
                    'label': '{% trans "Applying labels..." %}',
                    'send': '{% trans "Sending email..." %}',
                    'restore': '{% trans "Restoring emails..." %}'
                };
                
                let message = '{% trans "Processing your request..." %}';
                for (const [key, value] of Object.entries(commandMessages)) {
                    if (command.includes(key)) {
                        message = value;
                        break;
                    }
                }
                
                console.log('Loading message:', message); // Debug log
                showLoadingScreen('{% trans "Processing..." %}', message);
                
                // Connect to real-time progress updates for general commands
                connectToProgressStream(commandId, 'general');
                
                // Fallback: Start a simple progress animation in case SSE fails
                let fallbackProgress = 0;
                const fallbackInterval = setInterval(() => {
                    fallbackProgress += Math.random() * 8 + 4; // 4-12% increments
                    if (fallbackProgress > 95) fallbackProgress = 95;
                    updateProgress(fallbackProgress);
                }, 300);
                
                // Store interval for cleanup
                window.fallbackProgressInterval = fallbackInterval;
            }
            
            // Add command ID to form for backend processing
            const commandIdInput = document.createElement('input');
            commandIdInput.type = 'hidden';
            commandIdInput.name = 'command_id';
            commandIdInput.value = commandId;
            document.getElementById('command-form').appendChild(commandIdInput);
            
            // Submit form immediately - loading screen will show during actual command execution
            // No preventDefault() - let the form submit naturally
        });
    });

    // Loading Screen Functions (moved outside DOMContentLoaded to be globally accessible)
    window.showLoadingScreen = function(title, message, showSteps = false) {
        document.getElementById('loadingTitle').textContent = title;
        document.getElementById('loadingMessage').textContent = message;
        document.getElementById('loadingScreen').style.display = 'flex';
        updateProgress(0);
        
        // Show/hide steps based on parameter
        const stepsEl = document.getElementById('generalSteps');
        if (stepsEl) {
            stepsEl.style.display = showSteps ? 'block' : 'none';
            if (showSteps) {
                // Reset all steps to inactive
                setGeneralStep(1, 'inactive');
                setGeneralStep(2, 'inactive');
                setGeneralStep(3, 'inactive');
                // Update step names to Hebrew if needed
                updateGeneralStepNames();
            }
        }
        
        // Add a close button for testing
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = 'position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer;';
        closeBtn.onclick = function() {
            hideLoadingScreen();
            closeBtn.remove();
        };
        document.getElementById('loadingScreen').appendChild(closeBtn);
    };

    window.hideLoadingScreen = function() {
        document.getElementById('loadingScreen').style.display = 'none';
    };

    // General step management function
    window.setGeneralStep = function(stepNumber, status) {
        const stepEl = document.getElementById(`generalStep${stepNumber}`);
        if (stepEl) {
            stepEl.className = `stats-step ${status}`;
        }
    };

    window.updateProgress = function(percent, message) {
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const loadingMessage = document.getElementById('loadingMessage');
        
        console.log('Updating progress:', percent, 'Elements found:', {
            progressFill: !!progressFill,
            progressText: !!progressText,
            loadingMessage: !!loadingMessage
        });
        
        if (progressFill) {
            progressFill.style.width = percent + '%';
        }
        if (progressText) {
            progressText.textContent = Math.round(percent) + '%';
        }
        if (message && loadingMessage) {
            loadingMessage.textContent = message;
        }
    };

    window.showStatsLoadingScreen = function() {
        document.getElementById('statsLoadingScreen').style.display = 'flex';
        updateStatsProgress(0, '{% trans "Initializing analysis..." %}');
        resetStatsSteps();
        // Make sure stats steps are visible
        const statsDetails = document.querySelector('#statsLoadingScreen .stats-details');
        if (statsDetails) {
            statsDetails.style.display = 'block';
        }
        // Update step names based on current language
        updateStatsStepNames();
    };

    window.showEmailListingLoadingScreen = function() {
        document.getElementById('statsLoadingScreen').style.display = 'flex';
        updateStatsProgress(0, '{% trans "Starting email search..." %}');
        resetStatsSteps();
        // Hide stats steps for email listing
        const statsDetails = document.querySelector('#statsLoadingScreen .stats-details');
        if (statsDetails) {
            statsDetails.style.display = 'none';
        }
        // Update title for email listing
        updateEmailListingTitle();
    };

    window.hideStatsLoadingScreen = function() {
        document.getElementById('statsLoadingScreen').style.display = 'none';
    };

    window.updateStatsProgress = function(percent, message) {
        const progressFill = document.getElementById('statsProgressFill');
        const progressText = document.getElementById('statsProgressText');
        const loadingMessage = document.getElementById('statsLoadingMessage');
        
        progressFill.style.width = percent + '%';
        progressText.textContent = Math.round(percent) + '%';
        
        if (message) {
            loadingMessage.textContent = message;
        }
    };

    window.resetStatsSteps = function() {
        // Reset stats steps specifically
        for (let i = 1; i <= 3; i++) {
            const step = document.getElementById('statsStep' + i);
            if (step) {
                step.classList.remove('active', 'completed');
            }
        }
    };

    window.setStatsStep = function(stepNumber, status) {
        console.log('setStatsStep called:', stepNumber, status); // Debug log
        const step = document.getElementById('statsStep' + stepNumber);
        if (step) {
            console.log('Found stats step element:', step); // Debug log
            step.classList.remove('active', 'completed');
            if (status === 'active') {
                step.classList.add('active');
            } else if (status === 'completed') {
                step.classList.add('completed');
            }
        } else {
            console.log('Stats step element not found:', 'statsStep' + stepNumber); // Debug log
        }
    };

    window.updateStatsStepNames = function() {
        const isHebrew = document.documentElement.lang === 'he';
        const stepNames = {
            'en': ['Fetching emails...', 'Analyzing data...', 'Generating insights...'],
            'he': ['מביא מיילים...', 'מנתח נתונים...', 'יוצר תובנות...']
        };
        
        const titles = {
            'en': 'Analyzing Your Emails',
            'he': 'מנתח את המיילים שלך'
        };
        
        
        const language = isHebrew ? 'he' : 'en';
        const names = stepNames[language];
        
        // Update title
        const titleElement = document.querySelector('#statsLoadingScreen h3');
        if (titleElement) {
            titleElement.textContent = titles[language];
        }
        
        // Update step names
        for (let i = 1; i <= 3; i++) {
            const step = document.getElementById('statsStep' + i);
            if (step) {
                const stepText = step.querySelector('.step-text');
                if (stepText) {
                    stepText.textContent = names[i - 1];
                }
            }
        }
    };

    window.updateEmailListingTitle = function() {
        const isHebrew = document.documentElement.lang === 'he';
        const titles = {
            'en': 'Loading Your Emails',
            'he': 'טוען את המיילים שלך'
        };
        
        const language = isHebrew ? 'he' : 'en';
        
        // Update title
        const titleElement = document.querySelector('#statsLoadingScreen h3');
        if (titleElement) {
            titleElement.textContent = titles[language];
        }
    };

    window.updateGeneralStepNames = function() {
        const isHebrew = document.documentElement.lang === 'he';
        const stepNames = {
            'en': ['Collecting emails...', 'Analyzing content...', 'Generating insights...'],
            'he': ['אוסף מיילים...', 'מנתח תוכן...', 'יוצר תובנות...']
        };
        
        const language = isHebrew ? 'he' : 'en';
        const names = stepNames[language];
        
        // Update step names
        for (let i = 1; i <= 3; i++) {
            const step = document.getElementById('generalStep' + i);
            if (step) {
                const stepText = step.querySelector('.step-text');
                if (stepText) {
                    stepText.textContent = names[i - 1];
                }
            }
        }
    };

    // Real-time progress stream connection
    window.connectToProgressStream = function(commandId, type) {
        console.log('Connecting to progress stream for command:', commandId);
        console.log('SSE URL:', `/agent/progress/${commandId}/`);
        
        const eventSource = new EventSource(`/agent/progress/${commandId}/`);
        
        eventSource.onopen = function(event) {
            console.log('SSE connection opened:', event);
        };
        
        eventSource.onmessage = function(event) {
            console.log('SSE message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                console.log('Parsed progress data:', data);
                
                if (type === 'stats') {
                    console.log('Stats progress received:', data); // Debug log
                    // Clear fallback progress when real progress is received
                    if (window.fallbackStatsProgressInterval) {
                        clearInterval(window.fallbackStatsProgressInterval);
                        window.fallbackStatsProgressInterval = null;
                    }
                    if (window.fallbackEmailProgressInterval) {
                        clearInterval(window.fallbackEmailProgressInterval);
                        window.fallbackEmailProgressInterval = null;
                    }
                    
                    updateStatsProgress(data.progress, data.message);
                    
                    // Only update steps if they are visible (for stats commands)
                    const statsDetails = document.querySelector('#statsLoadingScreen .stats-details');
                    if (statsDetails && statsDetails.style.display !== 'none') {
                        // Update steps based on progress
                        console.log('Updating stats steps based on progress:', data.progress); // Debug log
                        if (data.progress < 30) {
                            setStatsStep(1, 'active');
                        } else if (data.progress < 70) {
                            setStatsStep(1, 'completed');
                            setStatsStep(2, 'active');
                        } else {
                            setStatsStep(2, 'completed');
                            setStatsStep(3, 'active');
                        }
                    }
                    
                    if (data.complete) {
                        setStatsStep(3, 'completed');
                        eventSource.close();
                    }
                } else {
                    // Clear fallback progress when real progress is received
                    if (window.fallbackProgressInterval) {
                        clearInterval(window.fallbackProgressInterval);
                        window.fallbackProgressInterval = null;
                    }
                    
                    // Update general loading message and progress
                    const stepsEl = document.getElementById('generalSteps');
                    if (stepsEl && stepsEl.style.display !== 'none') {
                        // When steps are shown, don't update the main loading message
                        // Instead, update the appropriate step based on progress
                        // Ensure step names are in the correct language
                        updateGeneralStepNames();
                        
                        if (data.progress < 30) {
                            setGeneralStep(1, 'active');
                        } else if (data.progress < 70) {
                            setGeneralStep(1, 'completed');
                            setGeneralStep(2, 'active');
                        } else {
                            setGeneralStep(2, 'completed');
                            setGeneralStep(3, 'active');
                        }
                    } else {
                        // When steps are not shown, update the main loading message
                        if (data && typeof data.message === 'string') {
                            const msgEl = document.getElementById('loadingMessage');
                            if (msgEl) msgEl.textContent = data.message;
                        }
                    }
                    updateProgress(data.progress);
                    
                    if (data.complete) {
                        if (stepsEl && stepsEl.style.display !== 'none') {
                            setGeneralStep(3, 'completed');
                        }
                        eventSource.close();
                    }
                }
            } catch (e) {
                console.error('Error parsing progress data:', e);
                console.error('Raw data:', event.data);
            }
        };
        
        eventSource.onerror = function(event) {
            console.error('Progress stream error:', event);
            console.error('EventSource readyState:', eventSource.readyState);
            eventSource.close();
        };
        
        // Store reference for cleanup if needed
        window.currentProgressStream = eventSource;
    };
    </script>

    <!-- General loading screen -->
    <div id="loadingScreen" class="loading-overlay" style="display: none;">
        <div class="loading-container">
            <div class="loading-spinner"></div>
            <h3 id="loadingTitle">{% trans 'Processing...' %}</h3>
            <p id="loadingMessage">{% trans 'Please wait while we process your request' %}</p>
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill"></div>
                </div>
                <span id="progressText">0%</span>
            </div>
            <div class="stats-details" id="generalSteps" style="display: none;">
                <div class="stats-step" id="generalStep1">
                    <span class="step-icon">📧</span>
                    <span class="step-text">{% trans 'Collecting emails...' %}</span>
                </div>
                <div class="stats-step" id="generalStep2">
                    <span class="step-icon">🔍</span>
                    <span class="step-text">{% trans 'Analyzing content...' %}</span>
                </div>
                <div class="stats-step" id="generalStep3">
                    <span class="step-icon">📊</span>
                    <span class="step-text">{% trans 'Generating insights...' %}</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Email Stats loading screen -->
    <div id="statsLoadingScreen" class="loading-overlay" style="display: none;">
        <div class="loading-container stats-loading">
            <div class="loading-spinner"></div>
            <h3>{% trans 'Analyzing Your Emails' %}</h3>
            <p id="statsLoadingMessage">{% trans 'Fetching email data...' %}</p>
            <div class="progress-container">
                <div class="progress-bar">
                    <div id="statsProgressFill" class="progress-fill"></div>
                </div>
                <span id="statsProgressText">0%</span>
            </div>
            <div class="stats-details">
                <div class="stats-step" id="statsStep1">
                    <span class="step-icon">📧</span>
                    <span class="step-text">{% trans 'Fetching emails...' %}</span>
                </div>
                <div class="stats-step" id="statsStep2">
                    <span class="step-icon">📊</span>
                    <span class="step-text">{% trans 'Analyzing data...' %}</span>
                </div>
                <div class="stats-step" id="statsStep3">
                    <span class="step-icon">📈</span>
                    <span class="step-text">{% trans 'Generating insights...' %}</span>
                </div>
            </div>
        </div>
    </div>
</body>
</html>

